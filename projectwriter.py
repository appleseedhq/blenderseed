
#
# This source file is part of appleseed.
# Visit https://appleseedhq.net/ for additional information and resources.
#
# This software is released under the MIT license.
#
# Copyright (c) 2014-2018 The appleseedhq Organization
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import codecs
import math
import os
from datetime import datetime

import bpy
import mathutils

from . import geometrywriter
from . import util

identity_matrix = mathutils.Matrix(((1.0, 0.0, 0.0, 0.0),
                                    (0.0, 0.0, -1.0, 0.0),
                                    (0.0, 1.0, 0.0, 0.0),
                                    (0.0, 0.0, 0.0, 1.0)))

image_extensions = ('jpg', 'png', 'tif', 'exr', 'bmp', 'tga', 'hdr', 'dpx', 'psd', 'gif', 'jp2')


def is_black(color):
    return color[0] == 0.0 and color[1] == 0.0 and color[2] == 0.0


def add(color1, color2):
    return [color1[0] + color2[0], color1[1] + color2[1], color1[2] + color2[2]]


def mul(color, multiplier):
    return [color[0] * multiplier, color[1] * multiplier, color[2] * multiplier]


def object_enumerator(obj_type):
    matches = []
    for obj in bpy.data.objects:
        if obj.type == obj_type:
            matches.append((obj.name, obj.name, ""))
    return matches


class Writer(object):
    """appleseed exporter."""

    def write(self, scene, file_path, animation=False):
        """Write the .appleseed project file for rendering."""

        if scene is None:
            self.__error("No scene to export.")
            return

        # Root path of the exported project.
        self._root_path = os.path.dirname(util.realpath(file_path))

        # Whether this is an exported animation.
        self._animation = animation

        # Transformation matrix applied to all entities of the scene.
        self._global_scale = 1
        self._global_matrix = mathutils.Matrix.Scale(self._global_scale, 4)

        # Store textures as they are exported.
        self._textures_set = set()

        # Collect objects with motion blur.
        self._def_mblur_obs = {ob.name: '' for ob in scene.objects if ob.appleseed.enable_motion_blur and ob.appleseed.motion_blur_type == 'deformation'}
        self._selected_objects = [ob.name for ob in scene.objects if ob.select]
        self._dupli_objects = []

        # Blender material -> front material name, back material name.
        self._emitted_materials = {}

        # Object name -> instance count.
        self._instance_count = {}
        self._assembly_count = {}
        self._assembly_instance_count = {}

        # Object name -> (material index, mesh name).
        self._mesh_parts = {}

        # Instanced particle objects.
        # Write mesh files but do not write to appleseed file.
        self._no_export = {ob.name for ob in util.get_all_psysobs()}

        self.__info("")
        self.__info("Starting export of scene '{0}' to {1}...".format(scene.name, file_path))

        start_time = datetime.now()

        try:
            with codecs.open(file_path, "w", "utf-8") as self._output_file:
                self._indent = 0
                self.__emit_file_header()
                self.__emit_project(scene)
        except IOError:
            self.__error("Could not write to {0}.".format(file_path))
            return

        elapsed_time = datetime.now() - start_time

        self.__info("Finished exporting in {0}".format(elapsed_time))

    """Export the project."""

    def __get_selected_camera(self, scene):
        if scene.camera is not None and scene.camera.name in bpy.data.objects:
            return scene.camera
        else:
            return None

    def __emit_file_header(self):
        self.__emit_line("<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
        self.__emit_line("<!-- File generated by {0} {1}. -->".format("blenderseed", util.version))

    def __emit_project(self, scene):
        self.__open_element("project format_revision=\"25\"")
        self.__emit_search_paths()
        self.__emit_scene(scene)
        self.__emit_output(scene)
        self.__emit_configurations(scene)
        self.__close_element("project")

    def __emit_search_paths(self):
        osl_path, shader_directories = util.get_osl_search_paths()
        self.__open_element("search_paths")
        for path in shader_directories:
            self.__emit_search_path(path)
        self.__close_element("search_paths")

    def __emit_search_path(self, path):
        self.__open_element("search_path")
        self.__emit_line(path)
        self.__close_element("search_path")

    def __emit_scene(self, scene):
        self.__open_element("scene")
        self.__emit_camera(scene)
        self.__emit_environment(scene)
        self.__emit_assembly(scene)
        self.__emit_assembly_instance(scene)
        self.__close_element("scene")

    def __emit_assembly(self, scene):
        """Write the scene assembly."""

        self.__open_element('assembly name="{0}"'.format(scene.name))
        self.__emit_physical_surface_shader_element()
        self.__emit_default_material(scene)
        self.__emit_objects(scene)
        self.__close_element("assembly")

    def __emit_assembly_instance(self, scene, obj=None):
        """
        Write a scene assembly instance, or write an assembly
        instance for an object with transformation motion blur.
        """

        asr_scn = scene.appleseed
        shutter_open = asr_scn.shutter_open if asr_scn.enable_motion_blur else 0
        shutter_close = asr_scn.shutter_close if asr_scn.enable_motion_blur else 1
        if obj is not None:
            # Write object assembly for an object with motion blur.
            obj_name = obj.name
            self.__open_element('assembly_instance name="{0}_instance" assembly="{1}"'.format(obj_name, obj_name))
            current_frame = scene.frame_current

            # Advance to shutter open, collect matrix.
            scene.frame_set(current_frame, subframe=shutter_open)
            instance_matrix = self._global_matrix * obj.matrix_world

            # Advance to next frame, collect matrix.
            scene.frame_set(current_frame, subframe=shutter_close)
            next_matrix = self._global_matrix * obj.matrix_world

            # Reset timeline.
            scene.frame_set(current_frame)

            self.__emit_transform_element(instance_matrix, 0)
            self.__emit_transform_element(next_matrix, 1)
            self.__close_element("assembly_instance")
        else:
            # No object, write an assembly for the whole scene.
            self.__open_element('assembly_instance name="{0}_instance" assembly="{1}"'.format(scene.name, scene.name))
            self.__close_element("assembly_instance")

    # --------------------------------
    def __emit_object_assembly(self, scene, object):
        """Write an assembly for an object with transformation motion blur."""

        object_name = object.name
        self.__open_element('assembly name="{0}"'.format(object_name))
        self.__emit_physical_surface_shader_element()
        self.__emit_default_material(scene)
        self.__emit_geometric_object(scene, object, True)
        self.__close_element("assembly")

    # --------------------------------
    def __emit_dupli_assembly(self, scene, object, matrices):
        """Write an assembly for a dupli/particle with transformation motion blur."""

        object_name = object.name
        # Figure out the instance number of this assembly instance.
        if object_name in self._assembly_count:
            instance_index = self._assembly_count[object_name] + 1
        else:
            instance_index = 0
        self._assembly_count[object_name] = instance_index

        assembly_name = "{0}_{1}".format(object_name, instance_index)
        self.__open_element('assembly name="{0}"'.format(assembly_name))
        self.__emit_physical_surface_shader_element()
        self.__emit_default_material(scene)
        self.__emit_dupli_object(scene, object, matrices, True, new_assembly=True)
        self.__close_element("assembly")
        # Emit an instance of the dupli object assembly.
        self.__emit_dupli_assembly_instance(scene, assembly_name, matrices)

    # --------------------------------
    def __emit_dupli_assembly_instance(self, scene, assembly_name, matrices):
        """Write an instance of the dupli object assembly (for duplis/particles with motion blur)."""

        asr_scn = scene.appleseed
        # Figure out the instance number of this assembly instance.
        if assembly_name in self._assembly_instance_count:
            instance_index = self._assembly_instance_count[assembly_name] + 1
        else:
            instance_index = 0
        self._assembly_instance_count[assembly_name] = instance_index

        self.__open_element('assembly_instance name="{0}.instance_{1}" assembly="{2}"'.format(assembly_name, instance_index, assembly_name))

        instance_matrix = self._global_matrix * matrices[0].copy()
        next_matrix = self._global_matrix * matrices[1].copy()

        # Emit transformation matrices with their respective times.
        self.__emit_transform_element(instance_matrix, 0)
        self.__emit_transform_element(next_matrix, 1)
        self.__close_element("assembly_instance")

    # --------------------------------
    def __emit_objects(self, scene):
        """Emit the objects in the scene."""

        for object in scene.objects:
            if util.do_export(object, scene):  # Skip objects marked as non-renderable.
                if object.type == 'LAMP':
                    self.__emit_light(scene, object)
                else:
                    self._dupli_objects.clear()
                    if util.ob_mblur_enabled(object, scene):
                        if object.is_duplicator and object.dupli_type in {'VERTS', 'FACES'}:
                            # Motion blur enabled on a dupli parent
                            self._dupli_objects = util.get_instances(object, scene)
                            for dupli_obj in self._dupli_objects:
                                # Each "dupli" in dupli_objects is a nested list: [dupli.object, [object.matrix1, object.matrix2]]
                                inst_mats = dupli_obj[1]
                                self.__emit_dupli_assembly(scene, dupli_obj[0], inst_mats)

                        elif util.is_psys_emitter(object):
                            # Motion blur enabled on a particle system emitter.
                            particle_obs = util.get_psys_instances(object, scene)
                            for ob in particle_obs:  # each 'ob' is a particle, as dict key
                                # The value is a list: dupli.object and another list of two matrices
                                dupli_obj = particle_obs[ob][0]  # The dupli.object
                                inst_mats = particle_obs[ob][1]  # The list of matrices
                                self.__emit_dupli_assembly(scene, dupli_obj, inst_mats)

                            if util.render_emitter(object):
                                self.__emit_object_assembly(scene, object)
                                self.__emit_assembly_instance(scene, obj=object)
                        else:
                            # No duplis, no particle systems.
                            self.__emit_object_assembly(scene, object)
                            self.__emit_assembly_instance(scene, obj=object)
                    else:
                        # No motion blur enabled.
                        self.__emit_geometric_object(scene, object, False)

    def __emit_geometric_object(self, scene, object, enable_object_blur=False):
        """
        Get scene objects and instances for emitting.
        Only emit dupli- objects if the object doesn't have moblur enabled.
        Dupli- objects with object motion blur are handled separately.
        """

        if not enable_object_blur:
            self._dupli_objects.clear()

            if object.parent and object.parent.dupli_type in {'VERTS', 'FACES'}:
                # todo: what about dupli type 'GROUP'?
                return

            if object.is_duplicator:
                self._dupli_objects.extend(util.get_instances(object, scene))
                if util.is_psys_emitter(object) and util.render_emitter(object):
                    self._dupli_objects.append([object, object.matrix_world])

            # No duplis or particle systems.
            else:
                self._dupli_objects = [(object, object.matrix_world)]

        # Motion blur is enabled
        else:
            self._dupli_objects = [(object, identity_matrix)]

        # Emit the dupli objects.
        for dupli_object in self._dupli_objects:
            self.__emit_dupli_object(scene, dupli_object[0], dupli_object[1], enable_object_blur)

    # --------------------------------
    def __emit_dupli_object(self, scene, object, object_matrix, enable_object_blur, new_assembly=False):
        """Emit objects / dupli objects."""

        asr_scn = scene.appleseed
        shutter_open = asr_scn.shutter_open if asr_scn.enable_motion_blur else 0
        current_frame = scene.frame_current
        do_def_blur = util.def_mblur_enabled(object, scene)
        """
        Emit the mesh object (and write it to disk) only the first time it is encountered.
        If it's a new assembly (for dupli motion blur), only emit the object without tesselating mesh.
        """
        export_mesh = True
        if new_assembly or object.name not in self._instance_count:
            try:
                # Export hair as curves, if enabled in settings.
                export_hair = scene.appleseed.export_hair and util.has_hairsys(object)
                if export_hair:
                    if not util.render_emitter(object):
                        export_mesh = False

                # If deformation motion blur is enabled, write deformation mesh to disk.
                if do_def_blur:
                    scene.frame_set(current_frame, subframe=asr_scn.shutter_close)
                    # Tessellate the object at the next frame to export mesh for deformation motion blur.
                    if export_mesh:
                        def_mesh = object.to_mesh(scene, True, 'RENDER', calc_tessface=True)
                        mesh_faces = def_mesh.tessfaces
                        mesh_uvtex = def_mesh.tessface_uv_textures
                        # Write the deformation motion blur mesh to disk.
                        self.__emit_def_mesh_object(scene, object, def_mesh, mesh_faces, mesh_uvtex)
                        # Delete the mesh.
                        bpy.data.meshes.remove(def_mesh)

                    if export_hair:
                        for mod in object.modifiers:
                            if mod.type == 'PARTICLE_SYSTEM' and mod.show_render:
                                psys = mod.particle_system
                                if psys.settings.type == 'HAIR' and psys.settings.render_type == 'PATH':
                                    mat_index = psys.settings.material - 1
                                    material = object.material_slots[mat_index].name
                                    # Write the deformation motion blur hair mesh to disk.
                                    self.__emit_def_curves_object(scene, object, psys.name)

                    # Reset the timeline to current frame
                    scene.frame_set(current_frame)

                # Tessellate the object at shutter open.
                scene.frame_set(current_frame, subframe=shutter_open)
                if export_mesh:
                    mesh = object.to_mesh(scene, True, 'RENDER', calc_tessface=True)
                    mesh_faces = mesh.tessfaces
                    mesh_uvtex = mesh.tessface_uv_textures
                    # Write the geometry to disk and emit a mesh object element.
                    self._mesh_parts[object.name] = self.__emit_mesh_object(scene, object, mesh, mesh_faces, mesh_uvtex, new_assembly, do_def_blur)
                    # Delete the mesh
                    bpy.data.meshes.remove(mesh)

                if export_hair:
                    for mod in object.modifiers:
                        if mod.type == 'PARTICLE_SYSTEM' and mod.show_render:
                            psys = mod.particle_system
                            if psys.settings.type == 'HAIR' and psys.settings.render_type == 'PATH':
                                mat_index = psys.settings.material - 1
                                material = object.material_slots[mat_index].name
                                # Write the curves to disk and emit a curves object element.
                                self._mesh_parts["_".join([object.name, psys.name])] = self.__emit_curves_object(scene, object, psys, new_assembly)

                                # Emit the curves object instance.
                                self.__emit_mesh_object_instance(scene, object, self._global_matrix, new_assembly,
                                                                 hair=True, hair_material=material, psys_name=psys.name)

                # Reset timeline.
                scene.frame_set(current_frame)

            except RuntimeError:
                self.__info("Skipping object '{0}' of type '{1}' because it could not be converted to a mesh.".format(object.name, object.type))
                return

        # Emit the object instance.
        if export_mesh:
            self.__emit_mesh_object_instance(scene, object, object_matrix, new_assembly)

    def __emit_curves_object(self, scene, object, psys, new_assembly=False):
        """
        Emit the curves object element and write to disk.
        Return mesh parts to self._mesh_parts["_".join( [object.name, psys.name])]
        """

        curves_name = "_".join([object.name, psys.name])
        curves_filename = curves_name + ".curves"

        meshes_path = os.path.join(self._root_path, "meshes")
        export_curves = False
        if scene.appleseed.generate_mesh_files:
            curves_filepath = os.path.join(meshes_path, curves_filename)
            if not os.path.exists(meshes_path):
                os.mkdir(meshes_path)
            if scene.appleseed.export_mode == 'all':
                export_curves = True
            if (scene.appleseed.export_mode == 'partial' or self._animation) and not os.path.exists(curves_filepath):
                export_curves = True
            if scene.appleseed.export_mode == 'selected' and object.name in self._selected_objects:
                export_curves = True
            if new_assembly and curves_name in self._instance_count:
                export_curves = False
            if export_curves:
                # Export curves file to disk.
                self.__progress("Exporting particle system '{0}' to {1}...".format(psys.name, curves_filename))
                try:
                    geometrywriter.write_curves_to_disk(object, scene, psys, curves_filepath)
                except IOError:
                    self.__error("While exporting particle system '{0}': could not write to {1}, skipping particle system.".format(
                        psys.name, curves_filepath))
                    return []

        self.__emit_curves_element(curves_name, curves_filename, object, scene)
        # Hard code one mesh part for now, since particle systems aren't split into materials.
        return [(0, "part_0")]

    def __emit_mesh_object(self, scene, object, mesh, mesh_faces, mesh_uvtex, new_assembly, do_def_blur=False):
        """
        Emit the mesh object element and write to disk.
        Return mesh parts to self._mesh_parts[object.name]
        """

        if len(mesh_faces) == 0:
            self.__info("Skipping object '{0}' since it has no faces once converted to a mesh.".format(object.name))
            return []

        object_name = object.name

        mesh_filename = "{0}.obj".format(object_name) if not do_def_blur else "{0}_{1}.obj".format(object_name, scene.frame_current)
        meshes_path = os.path.join(self._root_path, "meshes")
        export_mesh = False
        if scene.appleseed.generate_mesh_files:
            mesh_filepath = os.path.join(meshes_path, mesh_filename)
            if not os.path.exists(meshes_path):
                os.mkdir(meshes_path)
            if scene.appleseed.export_mode == 'all':
                export_mesh = True
            if (scene.appleseed.export_mode == 'partial' or self._animation) and not os.path.exists(mesh_filepath):
                export_mesh = True
            if scene.appleseed.export_mode == 'selected' and object.name in self._selected_objects:
                export_mesh = True
            if new_assembly and object.name in self._instance_count:
                export_mesh = False
            if export_mesh:
                # Export the mesh to disk.
                self.__progress("Exporting object '{0}' to {1}...".format(object_name, mesh_filename))
                try:
                    mesh_parts = geometrywriter.write_mesh_to_disk(object, scene, mesh, mesh_filepath)
                except IOError:
                    self.__error("While exporting object '{0}': could not write to {1}, skipping this object.".format(object.name, mesh_filepath))
                    return []

        if scene.appleseed.generate_mesh_files == False or export_mesh == False:
            # Build a list of mesh parts just as if we had exported the mesh to disk.
            material_indices = set()
            for face in mesh_faces:
                material_indices.add(face.material_index)
            mesh_parts = map(lambda material_index: (material_index, "part_{0}".format(material_index)), material_indices)

        # Emit object.
        self.__emit_object_element(object_name, mesh_filename, object, scene)

        return mesh_parts

    def __emit_object_element(self, object_name, mesh_file, object, scene):
        """Emit an object element to the project file."""

        if object.appleseed.object_alpha_use_texture:
            self.__emit_texture(None, False, scene, None, None, False, object)
            alpha = object.name + "_alpha_inst"
        else:
            alpha = object.appleseed.object_alpha

        mesh_filename = "meshes" + os.path.sep + mesh_file
        self.__open_element('object name="' + object_name + '" model="mesh_object"')
        self.__emit_parameter("alpha_map", alpha)
        if util.def_mblur_enabled(object, scene):
            self.__open_element('parameters name="filename"')
            self.__emit_parameter("0", mesh_filename)
            self.__emit_parameter("1", "meshes" + os.path.sep + self._def_mblur_obs[object_name])
            self.__close_element("parameters")
        else:
            self.__emit_parameter("filename", mesh_filename)
        self.__close_element("object")

    def __emit_curves_element(self, curves_name, curves_file, object, scene):
        """Emit a curves object element to the project file."""

        curves_filename = "meshes" + os.path.sep + curves_file
        self.__open_element('object name="' + curves_name + '" model="curve_object"')
        if util.def_mblur_enabled(object, scene):
            self.__open_element('parameters name="filepath"')
            self.__emit_parameter("0", curves_filename)
            self.__emit_parameter("1", "meshes" + os.path.sep + self._def_mblur_obs[curves_name])
            self.__close_element("parameters")
        else:
            self.__emit_parameter("filepath", curves_filename)
        self.__close_element("object")

    def __emit_def_mesh_object(self, scene, object, mesh, mesh_faces, mesh_uvtex):
        """Emit a deformation mesh object and write to disk."""

        if len(mesh_faces) == 0:
            self.__info("Skipping object '{0}' since it has no faces once converted to a mesh.".format(object.name))
            return []
        object_name = object.name
        mesh_filename = "{0}_{1}_deform.obj".format(object_name, scene.frame_current)

        self._def_mblur_obs[object_name] = mesh_filename

        meshes_path = os.path.join(self._root_path, "meshes")
        export_mesh = False
        if scene.appleseed.generate_mesh_files:
            mesh_filepath = os.path.join(meshes_path, mesh_filename)
            if not os.path.exists(meshes_path):
                os.mkdir(meshes_path)
            if scene.appleseed.export_mode == 'all':
                export_mesh = True
            if (scene.appleseed.export_mode == 'partial' or self._animation) and not os.path.exists(mesh_filepath):
                export_mesh = True
            if scene.appleseed.export_mode == 'selected' and object.name in self._selected_objects:
                export_mesh = True
            if export_mesh:
                # Export the mesh to disk.
                self.__progress("Exporting object '{0}' to {1}...".format(object_name, mesh_filename))
                try:
                    geometrywriter.write_mesh_to_disk(object, scene, mesh, mesh_filepath)
                except IOError:
                    self.__error("While exporting object '{0}': could not write to {1}, skipping this object.".format(object.name, mesh_filepath))

    def __emit_def_curves_object(self, scene, object, psys):
        """Emit a curves deformation mesh object and write to disk."""

        curves_name = "_".join([object.name, psys.name])
        curves_filename = curves_name + "_deform.curves"

        self._def_mblur_obs[curves_name] = curves_filename

        meshes_path = os.path.join(self._root_path, "meshes")
        export_curves = False
        if scene.appleseed.generate_mesh_files:
            curves_filepath = os.path.join(meshes_path, curves_filename)
            if not os.path.exists(meshes_path):
                os.mkdir(meshes_path)
            if scene.appleseed.export_mode == 'all':
                export_curves = True
            if (scene.appleseed.export_mode == 'partial' or self._animation) and not os.path.exists(curves_filepath):
                export_curves = True
            if scene.appleseed.export_mode == 'selected' and object.name in self._selected_objects:
                export_curves = True
            if export_curves:
                # Export curves file to disk.
                self.__progress("Exporting particle system '{0}' to {1}...".format(psys.name, curves_filename))
                try:
                    geometrywriter.write_curves_to_disk(object, scene, psys, curves_filepath)
                except IOError:
                    self.__error("While exporting particle system '{0}': could not write to {1}, skipping particle system.".format(
                        psys.name, curves_filepath))

    def __emit_mesh_object_instance(self, scene, object, object_matrix, new_assembly, hair=False, hair_material=None, psys_name=None):
        """Calls __emit_object_instance_element to emit an object instance."""

        object_name = "_".join([object.name, psys_name]) if hair else object.name
        if new_assembly:
            object_matrix = self._global_matrix * identity_matrix
        else:
            object_matrix = self._global_matrix * object_matrix

        # Emit BSDFs and materials if they are encountered for the first time.
        for material_slot_index, material_slot in enumerate(object.material_slots):
            material = material_slot.material
            if material is None:
                self.__warning("While exporting instance of object '{0}': material slot #{1} has no material.".format(
                    object.name, material_slot_index))
                continue
            if new_assembly or material not in self._emitted_materials:
                # Need to emit material again if it's in a separate assembly.
                self._emitted_materials[material] = self.__emit_material(material, scene)

        # Figure out the instance number of this object.
        if not new_assembly and object_name in self._instance_count:
            instance_index = self._instance_count[object_name] + 1
        else:
            instance_index = 0
        self._instance_count[object_name] = instance_index

        # Emit object parts instances.
        for (material_index, mesh_name) in self._mesh_parts[object_name]:
            # A hack for now:
            # Is there a bug in how this is being interpreted by appleseed?
            if not hair:
                part_name = "{0}.{1}".format(object_name, mesh_name)
            else:
                part_name = object_name
            instance_name = "{0}.instance_{1}".format(part_name, instance_index)
            front_material_name = "__default_material"
            back_material_name = "__default_material"
            if material_index < len(object.material_slots):
                if not hair:
                    material = object.material_slots[material_index].material
                else:
                    material = bpy.data.materials[hair_material]
                if material:
                    front_material_name, back_material_name = self._emitted_materials[material]

            self.__emit_object_instance_element(part_name, instance_name, object_matrix, front_material_name, back_material_name, object, scene)

    def __emit_object_instance_element(self, object_name, instance_name, instance_matrix, front_material_name, back_material_name, object, scene):
        """Emit an object instance element to the project file."""

        self.__open_element('object_instance name="{0}" object="{1}"'.format(instance_name, object_name))
        if object.appleseed.enable_visibility_flags:
            self.__emit_visibility_flags(object)
        if object.appleseed.medium_priority > 0:
            self.__emit_parameter("medium_priority", object.appleseed.medium_priority)
        if object.appleseed.ray_bias_method != 'none':
            self.__emit_parameter("ray_bias_method", object.appleseed.ray_bias_method)
            self.__emit_parameter("ray_bias_distance", object.appleseed.ray_bias_distance)
        if object.appleseed.object_sss_set != "":
            self.__emit_parameter("sss_set_id", object.appleseed.object_sss_set)
        if util.ob_mblur_enabled(object, scene):
            self.__emit_transform_element(identity_matrix, None)
        else:
            self.__emit_transform_element(instance_matrix, None)
        self.__emit_line('<assign_material slot="0" side="front" material="{0}" />'.format(front_material_name))
        self.__emit_line('<assign_material slot="0" side="back" material="{0}" />'.format(back_material_name))
        self.__close_element("object_instance")

    def __emit_visibility_flags(self, object):
        """Emit visibility flags into the object instance"""

        ob_flags = object.appleseed
        self.__open_element('parameters name="visibility"')
        self.__emit_parameter("camera", str(ob_flags.camera_visible).lower())
        self.__emit_parameter("light", str(ob_flags.light_visible).lower())
        self.__emit_parameter("shadow", str(ob_flags.shadow_visible).lower())
        self.__emit_parameter("transparency", str(ob_flags.transparency_visible).lower())
        self.__emit_parameter("probe", str(ob_flags.probe_visible).lower())
        self.__emit_parameter("diffuse", str(ob_flags.diffuse_visible).lower())
        self.__emit_parameter("glossy", str(ob_flags.glossy_visible).lower())
        self.__emit_parameter("specular", str(ob_flags.specular_visible).lower())
        self.__close_element("parameters")

    """Material(s) writing"""

    def __is_light_emitting_material(self, asr_mat, scene):

        return asr_mat.use_light_emission and scene.appleseed.export_emitting_obj_as_lights

    def __is_node_material(self, asr_mat, node_tree):
        if node_tree:
            for node in node_tree.nodes:
                if node.node_type == 'osl_surface':
                    return True
        return False

    def __emit_physical_surface_shader_element(self):
        self.__emit_line('<surface_shader name="physical_surface_shader" model="physical_surface_shader" />')

    def __emit_default_material(self, scene):
        self.__emit_solid_linear_rgb_color_element("__default_material_bsdf_reflectance", [0.8], 1.0)

        self.__open_element('bsdf name="__default_material_bsdf" model="lambertian_brdf"')
        self.__emit_parameter("reflectance", "__default_material_bsdf_reflectance")
        self.__close_element("bsdf")

        self.__emit_material_element("__default_material", "__default_material_bsdf", "", "", "", "physical_surface_shader", scene, "")

    def __emit_material(self, material, scene):
        """Write the material."""

        asr_mat = material.appleseed
        asr_node_tree = asr_mat.osl_node_tree
        use_nodes = self.__is_node_material(asr_mat, asr_node_tree)
        material_node = None
        node_list = None
        front_material_name = ""

        # If using nodes.
        if use_nodes:
            # Get all nodes. If specular btdf or diffuse btdf in the list, emit back material as well.
            for node in asr_node_tree.nodes:
                if node.node_type == 'osl_surface':
                    material_node = node
            node_list = material_node.traverse_tree()
        else:
            if asr_mat.bsdf_type in ['specular_btdf', 'diffuse_btdf']:
                front_material_name = material.name + "_front"
                back_material_name = material.name + "_back"
                self.__emit_front_material(material, front_material_name, scene)
                self.__emit_back_material(material, back_material_name, scene)

        # If we didn't find any, then we're only exporting front material.
        if front_material_name == "":
            front_material_name = material.name
            if use_nodes:
                surface_name = front_material_name + "_surface"
                self.__emit_osl_material(material, front_material_name, surface_name, scene, material_node, node_list)
                back_material_name = front_material_name
            else:
                self.__emit_front_material(material, front_material_name, scene)
                if self.__is_light_emitting_material(asr_mat, scene):
                    # Assign the default material to the back face if the front face emits light,
                    # as we don't want mesh lights to emit from both faces.
                    back_material_name = "__default_material"
                else:
                    back_material_name = front_material_name

        return front_material_name, back_material_name

    def __emit_osl_material(self, material, front_material_name, surface_name, scene, material_node, node_list):

        self.__emit_osl_shader_group(surface_name, node_list, material_node, scene)
        self.__emit_osl_element(front_material_name, surface_name)

    def __emit_front_material(self, material, material_name, scene):
        """Material_name here is material.name + _front"""

        bsdf_name, bssrdf_name, volume_name = self.__emit_front_material_tree(material, material_name, scene)

        if self.__is_light_emitting_material(material.appleseed, scene):
            edf_name = "{0}_edf".format(material_name)
            self.__emit_edf(material, edf_name, scene)
        else:
            edf_name = ""

        self.__emit_material_element(material_name, bsdf_name, edf_name, bssrdf_name, volume_name, "physical_surface_shader", scene, material)

    def __emit_back_material(self, material, material_name, scene):
        """Material_name here is material.name + "_back"""

        bsdf_name = self.__emit_back_material_bsdf_tree(material, material_name, scene)

        self.__emit_material_element(material_name, bsdf_name, "", "", "", "physical_surface_shader", scene, material)

    def __emit_osl_shader_group(self, front_material_name, node_list, material_node, scene):
        node_connections = []

        self.__open_element('shader_group name="{0}"'.format(front_material_name))
        for node in node_list:
            self.__open_element('shader type="shader" name="{0}" layer="{1}"'.format(node.file_name, node.name))
            params = self.__get_osl_node_params(node, scene)
            for param in params:
                self.__emit_parameter(param, params[param])
            self.__close_element("shader")
            for x in self.__get_socket_links(node):
                node_connections.append(x)
        self.__open_element('shader type="surface" name="{0}" layer="{1}"'.format(material_node.file_name, material_node.name))
        self.__close_element("shader")
        for connection in node_connections:
            self.__emit_shader_connection(connection[0], connection[1], connection[2], connection[3])
        self.__close_element("shader_group")

    def __get_osl_node_params(self, node, scene):
        asr_scene_props = scene.appleseed
        parameters = {}
        parameter_types = node.parameter_types
        for key in parameter_types.keys():
            if key in dir(node):
                parameter_value = parameter_types[key]
                parameter = getattr(node, key)
                if key in node.filepaths:
                    parameter = bpy.path.abspath(parameter)
                    if scene.appleseed.sub_textures is True:
                        if parameter.endswith(image_extensions):
                            image_path_segments = os.path.split(parameter)
                            image_name = os.path.splitext(image_path_segments[1])
                            new_image_name = "{0}.tx".format(image_name[0])
                            if asr_scene_props.tex_output_use_cust_dir:
                                parameter = os.path.join(asr_scene_props.tex_output_dir, new_image_name)
                            else:
                                parameter = os.path.join(image_path_segments[0], new_image_name)


                if parameter_value == "int checkbox":
                    parameter_value = "int"
                    parameter = int(parameter)
                if parameter_value in ('color', 'vector', 'normal', 'float[2]'):
                    parameter =  " ".join(map(str, parameter))
                parameters[key] = parameter_value + " " + str(parameter)

        for socket in node.inputs:
            if not socket.is_linked:
                if socket.socket_value != "":
                    parameter_value = parameter_types[socket.socket_osl_id]
                    parameter = socket.get_socket_value(True)
                    if parameter_value in ('color', 'vector', 'normal', 'float[2]'):
                        parameter = " ".join(map(str, parameter))
                        if parameter_value == 'float[2]':
                            parameter_value = 'float[]'
                    parameters[socket.socket_osl_id] = parameter_value + " " + str(parameter)

        return parameters

    def __get_socket_links(self, node):
        connections = []
        for output in node.outputs:
            if output.is_linked:
                for link in output.links:
                    connections.append([node.name, output.socket_osl_id, link.to_node.name, link.to_socket.socket_osl_id])
        return connections

    def __emit_front_material_tree(self, material, material_name, scene):
        """
        Emit the front material's BSDF tree and return the last BSDF name to the calling function (__emit_front_material).
        """

        # material_name here is material.name + "_front"
        bsdf_name = ""
        bssrdf_name = ""
        volume_name = ""

        # If using nodes.

        asr_mat = material.appleseed
        if asr_mat.bsdf_type == "" and asr_mat.bssrdf_model == 'none' and asr_mat.volume_phase_function_model == 'none':
            bsdf_name = "__default_material_bsdf"
            return bsdf_name, bssrdf_name, volume_name
        else:
            # Spec BTDF
            if asr_mat.bsdf_type == "specular_btdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_specular_btdf(material, bsdf_name, scene, asr_mat)

            # Spec BRDF
            elif asr_mat.bsdf_type == "specular_brdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_specular_brdf(material, bsdf_name, scene, asr_mat)

            # Blinn BRDF
            elif asr_mat.bsdf_type == "blinn_brdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_blinn_brdf(material, bsdf_name, scene, asr_mat)

            # Glass BRDF
            elif asr_mat.bsdf_type == "glass_bsdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_glass_bsdf(material, bsdf_name, scene, asr_mat)

            # Metal BRDF
            elif asr_mat.bsdf_type == "metal_brdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_metal_brdf(material, bsdf_name, scene, asr_mat)

            # Plastic BRDF
            elif asr_mat.bsdf_type == "plastic_brdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_plastic_brdf(material, bsdf_name, scene, asr_mat)

            # Diffuse BTDF
            elif asr_mat.bsdf_type == "diffuse_btdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_diffuse_btdf(material, bsdf_name, scene, asr_mat)

            # Disney
            elif asr_mat.bsdf_type == "disney_brdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_disney_brdf(material, bsdf_name, scene, asr_mat=asr_mat)

            # Lambertian
            elif asr_mat.bsdf_type == "lambertian_brdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_lambertian_brdf(material, bsdf_name, scene, asr_mat)

            # Oren-Nayar
            elif asr_mat.bsdf_type == "orennayar_brdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_orennayar_brdf(material, bsdf_name, scene, asr_mat)

            # Ashikhmin
            elif asr_mat.bsdf_type == "ashikhmin_brdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_ashikhmin_brdf(material, bsdf_name, scene, asr_mat)

            # Sheen
            elif asr_mat.bsdf_type == "sheen_brdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_sheen_brdf(material, bsdf_name, scene, asr_mat)

            # Glossy
            elif asr_mat.bsdf_type == "glossy_brdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_glossy_brdf(material, bsdf_name, scene, asr_mat)

            # Kelemen
            elif asr_mat.bsdf_type == "kelemen_brdf":
                bsdf_name = "{0}_bsdf".format(material_name)
                self.__emit_kelemen_brdf(material, bsdf_name, scene, asr_mat)

            # Subsurface
            if asr_mat.bssrdf_model != 'none':
                bssrdf_name = "{0}_bssrdf".format(material_name)
                self.__emit_bssrdf(material, bssrdf_name, scene)

            # Volume
            if asr_mat.volume_phase_function_model != 'none':
                volume_name = "{0}_volume".format(material_name)
                self.__emit_volume(material, volume_name, scene)

            return bsdf_name, bssrdf_name, volume_name

    def __emit_back_material_bsdf_tree(self, material, material_name, scene):
        """Emits material tree for the back side of the object."""

        transp_bsdf_name = None
        asr_mat = material.appleseed

        if asr_mat.bsdf_type == "diffuse_btdf":
            transp_bsdf_name = "{0}_btdf".format(material_name)
            self.__emit_diffuse_btdf(material, transp_bsdf_name, scene, asr_mat)
        elif asr_mat.bsdf_type == "specular_btdf":
            transp_bsdf_name = "{0}_btdf".format(material_name)
            self.__emit_specular_btdf(material, transp_bsdf_name, scene, asr_mat)
        return transp_bsdf_name

    def __emit_lambertian_brdf(self, material, bsdf_name, scene, asr_mat=None):
        reflectance_name = ""

        if asr_mat.lambertian_brdf_use_diffuse_tex and asr_mat.lambertian_brdf_diffuse_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.lambertian_brdf_diffuse_tex]):
                reflectance_name = asr_mat.lambertian_brdf_diffuse_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.lambertian_brdf_diffuse_tex], False, scene)
        # TODO: add texture support for multiplier
        reflectance_multiplier = asr_mat.lambertian_brdf_multiplier

        if reflectance_name == "":
            reflectance_name = "{0}_lambertian_brdf_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(reflectance_name,
                                                       asr_mat.lambertian_brdf_reflectance,
                                                       1)
        # Emit BRDF.
        self.__open_element('bsdf name="{0}" model="lambertian_brdf"'.format(bsdf_name))
        self.__emit_parameter("reflectance", reflectance_name)
        self.__emit_parameter("reflectance_multiplier", reflectance_multiplier)
        self.__close_element("bsdf")

    def __emit_disney_brdf(self, material, bsdf_name, scene, asr_mat=None):
        base_coat_name = ""

        # Base Coat.
        if asr_mat.disney_brdf_use_base_tex and asr_mat.disney_brdf_base_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.disney_brdf_base_tex]):
                base_coat_name = asr_mat.disney_brdf_base_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.disney_brdf_base_tex], False, scene)

        else:
            base_coat_name = "{0}_disney_brdf_base_coat".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(base_coat_name,
                                                       asr_mat.disney_brdf_base,
                                                       1)

        # Specular.
        spec = asr_mat.disney_brdf_spec
        if asr_mat.disney_brdf_use_specular_tex and asr_mat.disney_brdf_specular_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.disney_brdf_specular_tex]):
                spec = asr_mat.disney_brdf_specular_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.disney_brdf_specular_tex], False, scene)

        # Specular Tint.
        specular_tint = asr_mat.disney_brdf_specular_tint
        if asr_mat.disney_brdf_use_specular_tint_tex and asr_mat.disney_brdf_specular_tint_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.disney_brdf_specular_tint_tex]):
                specular_tint = asr_mat.disney_brdf_specular_tint_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.disney_brdf_specular_tint_tex], False, scene)

        # Aniso.
        anisotropy = asr_mat.disney_brdf_anisotropy
        if asr_mat.disney_brdf_use_anisotropy_tex and asr_mat.disney_brdf_anisotropy_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.disney_brdf_anisotropy_tex]):
                anisotropy = asr_mat.disney_brdf_anisotropy_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.disney_brdf_anisotropy_tex], False, scene)

        # Clear Coat.
        clearcoat = asr_mat.disney_brdf_clearcoat
        if asr_mat.disney_brdf_use_clearcoat_tex and asr_mat.disney_brdf_clearcoat_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.disney_brdf_clearcoat_tex]):
                clearcoat = asr_mat.disney_brdf_clearcoat_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.disney_brdf_clearcoat_tex], False, scene)

        # Clear Coat Gloss.
        clearcoat_gloss = asr_mat.disney_brdf_clearcoat_gloss
        if asr_mat.disney_brdf_use_clearcoat_glossy_tex and asr_mat.disney_brdf_clearcoat_glossy_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.disney_brdf_clearcoat_glossy_tex]):
                clearcoat_gloss = asr_mat.disney_brdf_clearcoat_glossy_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.disney_brdf_clearcoat_glossy_tex], False, scene)

        # Metallic.
        metallic = asr_mat.disney_brdf_metallic
        if asr_mat.disney_brdf_use_metallic_tex and asr_mat.disney_brdf_metallic_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.disney_brdf_metallic_tex]):
                metallic = asr_mat.disney_brdf_metallic_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.disney_brdf_metallic_tex], False, scene)

        # Roughness.
        roughness = asr_mat.disney_brdf_roughness
        if asr_mat.disney_brdf_use_roughness_tex and asr_mat.disney_brdf_roughness_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.disney_brdf_roughness_tex]):
                roughness = asr_mat.disney_brdf_roughness_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.disney_brdf_roughness_tex], False, scene)

        # Sheen.
        sheen = asr_mat.disney_brdf_sheen
        if asr_mat.disney_brdf_use_sheen_brdf_tex and asr_mat.disney_brdf_sheen_brdf_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.disney_brdf_sheen_brdf_tex]):
                sheen = asr_mat.disney_brdf_sheen_brdf_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.disney_brdf_sheen_brdf_tex], False, scene)

        # Sheen Tint.
        sheen_brdf_tint = asr_mat.disney_brdf_sheen_brdf_tint
        if asr_mat.disney_brdf_use_sheen_brdf_tint_tex and asr_mat.disney_brdf_sheen_brdf_tint_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.disney_brdf_sheen_brdf_tint_tex]):
                sheen_brdf_tint = asr_mat.disney_brdf_sheen_brdf_tint_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.disney_brdf_sheen_brdf_tint_tex], False, scene)

        # Subsurface.
        subsurface = asr_mat.disney_brdf_subsurface
        if asr_mat.disney_brdf_use_subsurface_tex and asr_mat.disney_brdf_subsurface_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.disney_brdf_subsurface_tex]):
                subsurface = asr_mat.disney_brdf_subsurface_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.disney_brdf_subsurface_tex], False, scene)

        self.__open_element('bsdf name="{0}" model="disney_brdf"'.format(bsdf_name))
        self.__emit_parameter("anisotropic", anisotropy)
        self.__emit_parameter("base_color", base_coat_name)
        self.__emit_parameter("specular", spec)
        self.__emit_parameter("specular_tint", specular_tint)
        self.__emit_parameter("clearcoat", clearcoat)
        self.__emit_parameter("clearcoat_gloss", clearcoat_gloss)
        self.__emit_parameter("metallic", metallic)
        self.__emit_parameter("roughness", roughness)
        self.__emit_parameter("sheen", sheen)
        self.__emit_parameter("sheen_brdf_tint", sheen_brdf_tint)
        self.__emit_parameter("subsurface", subsurface)
        self.__close_element("bsdf")

    def __emit_orennayar_brdf(self, material, bsdf_name, scene, asr_mat=None):
        reflectance_name = ""

        if asr_mat.orennayar_brdf_use_diffuse_tex and asr_mat.orennayar_brdf_diffuse_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.orennayar_brdf_diffuse_tex]):
                reflectance_name = asr_mat.orennayar_brdf_diffuse_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.orennayar_brdf_diffuse_tex], False, scene)

        roughness = asr_mat.orennayar_brdf_roughness
        if asr_mat.orennayar_brdf_use_rough_tex and asr_mat.orennayar_brdf_rough_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.orennayar_brdf_rough_tex]):
                roughness = asr_mat.orennayar_brdf_rough_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.orennayar_brdf_rough_tex], False, scene)

        # TODO: add texture support for multiplier
        reflectance_multiplier = asr_mat.orennayar_brdf_reflectance_multiplier
        if asr_mat.orennayar_brdf_use_reflect_multiplier_tex and asr_mat.orennayar_brdf_reflect_multiplier_tex != '':
            if util.is_uv_img(bpy.data.textures[asr_mat.orennayar_brdf_reflect_multiplier_tex]):
                reflectance_multiplier = asr_mat.orennayar_brdf_reflect_multiplier_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.orennayar_brdf_reflect_multiplier_tex], False, scene)

        if reflectance_name == "":
            reflectance_name = "{0}_orennayar_brdf_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(reflectance_name,
                                                       asr_mat.orennayar_brdf_reflectance,
                                                       1)

        self.__open_element('bsdf name="{0}" model="orennayar_brdf"'.format(bsdf_name))
        self.__emit_parameter("reflectance", reflectance_name)
        self.__emit_parameter("reflectance_multiplier", reflectance_multiplier)
        self.__emit_parameter("roughness", roughness)
        self.__close_element("bsdf")

    def __emit_diffuse_btdf(self, material, bsdf_name, scene, asr_mat=None):
        transmittance_name = ""

        if asr_mat.diffuse_btdf_use_diffuse_tex and asr_mat.diffuse_btdf_diffuse_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.diffuse_btdf_diffuse_tex]):
                transmittance_name = asr_mat.diffuse_btdf_diffuse_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.diffuse_btdf_diffuse_tex], False, scene)

        if asr_mat.diffuse_btdf_transmittance_use_mult_tex and asr_mat.diffuse_btdf_transmittance_mult_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.diffuse_btdf_transmittance_mult_tex]):
                transmittance = asr_mat.diffuse_btdf_transmittance_mult_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.diffuse_btdf_transmittance_mult_tex], False, scene)

        if transmittance_name == "":
            transmittance_name = "{0}_diffuse_transmittance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(transmittance_name,
                                                       asr_mat.diffuse_btdf_transmittance_color,
                                                       1)
        # TODO: add texture support for multiplier
        transmittance = asr_mat.diffuse_btdf_transmittance_multiplier

        self.__open_element('bsdf name="{0}" model="diffuse_btdf"'.format(bsdf_name))
        self.__emit_parameter("transmittance", transmittance_name)
        self.__emit_parameter("transmittance_multiplier", transmittance)
        self.__close_element("bsdf")

    def __emit_sheen_brdf(self, material, bsdf_name, scene, asr_mat=None):
        reflectance = ""

        reflectance_multiplier = asr_mat.sheen_brdf_reflectance_multiplier
        # reflectance
        if asr_mat.sheen_brdf_reflectance_use_tex and asr_mat.sheen_brdf_reflectance_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.sheen_brdf_reflectance_tex]):
                reflectance = asr_mat.sheen_brdf_reflectance_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.sheen_brdf_reflectance_tex], False, scene)
        if reflectance == "":
            reflectance = "{0}_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(reflectance,
                                                       asr_mat.sheen_brdf_reflectance,
                                                       1)

        # reflectance multiplier
        if asr_mat.sheen_brdf_reflectance_multiplier_use_tex and asr_mat.sheen_brdf_reflectance_multiplier_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.sheen_brdf_reflectance_multiplier_tex]):
                reflectance_multiplier = asr_mat.sheen_brdf_reflectance_multiplier_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.sheen_brdf_reflectance_multiplier_tex], False, scene)

        self.__open_element('bsdf name="{0}" model="sheen_brdf"'.format(bsdf_name))
        self.__emit_parameter("reflectance", reflectance)
        self.__emit_parameter("reflectance_multiplier", reflectance_multiplier)
        self.__close_element("bsdf")

    def __emit_glossy_brdf(self, material, bsdf_name, scene, asr_mat=None):
        reflectance = ""
        reflectance_multiplier = asr_mat.glossy_brdf_reflectance_multiplier
        roughness = asr_mat.glossy_brdf_roughness
        anisotropy = asr_mat.glossy_brdf_anisotropy

        # reflectance
        if asr_mat.glossy_brdf_reflectance_use_tex and asr_mat.glossy_brdf_reflectance_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glossy_brdf_reflectance_tex]):
                reflectance = asr_mat.glossy_brdf_reflectance_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glossy_brdf_reflectance_tex], False, scene)
        if reflectance == "":
            reflectance = "{0}_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(reflectance,
                                                       asr_mat.glossy_brdf_reflectance,
                                                       1)

        # reflectance multiplier
        if asr_mat.glossy_brdf_reflectance_multiplier_use_tex and asr_mat.glossy_brdf_reflectance_multiplier_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glossy_brdf_reflectance_multiplier_tex]):
                reflectance_multiplier = asr_mat.glossy_brdf_reflectance_multiplier_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glossy_brdf_reflectance_multiplier_tex], False, scene)

        # roughness
        if asr_mat.glossy_brdf_roughness_use_tex and asr_mat.glossy_brdf_roughness_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glossy_brdf_roughness_tex]):
                roughness = asr_mat.glossy_brdf_roughness_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glossy_brdf_roughness_tex], False, scene)

        # anisotropy
        if asr_mat.glossy_brdf_anisotropy_use_tex and asr_mat.glossy_brdf_anisotropy_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glossy_brdf_anisotropy_tex]):
                anisotropy = asr_mat.glossy_brdf_anisotropy_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glossy_brdf_anisotropy_tex], False, scene)

        self.__open_element('bsdf name="{0}" model="glossy_brdf"'.format(bsdf_name))
        self.__emit_parameter("mdf", asr_mat.glossy_brdf_mdf)
        self.__emit_parameter("reflectance", reflectance)
        self.__emit_parameter("reflectance_multiplier", reflectance_multiplier)
        self.__emit_parameter("roughness", roughness)
        self.__emit_parameter("highlight_falloff", asr_mat.glossy_brdf_highlight_falloff)
        self.__emit_parameter("anisotropy", anisotropy)
        self.__emit_parameter("ior", asr_mat.glossy_brdf_ior)
        self.__close_element("bsdf")

    def __emit_ashikhmin_brdf(self, material, bsdf_name, scene, asr_mat=None):
        diffuse_reflectance_name = ""
        glossy_brdf_reflectance_name = ""

        if asr_mat.ashikhmin_brdf_use_diffuse_tex and asr_mat.ashikhmin_brdf_diffuse_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.ashikhmin_brdf_diffuse_tex]):
                diffuse_reflectance_name = asr_mat.ashikhmin_brdf_diffuse_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.ashikhmin_brdf_diffuse_tex], False, scene)

        if asr_mat.ashikhmin_brdf_use_glossy_tex and asr_mat.ashikhmin_brdf_glossy_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.ashikhmin_brdf_glossy_tex]):
                glossy_brdf_reflectance_name = asr_mat.ashikhmin_brdf_glossy_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.ashikhmin_brdf_glossy_tex], False, scene)

        # Make sure we found some textures. If not, default to material color.
        if diffuse_reflectance_name == "":
            diffuse_reflectance_name = "{0}_ashikhmin_brdf_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(diffuse_reflectance_name,
                                                       asr_mat.ashikhmin_brdf_reflectance,
                                                       1)
        if glossy_brdf_reflectance_name == "":
            glossy_brdf_reflectance_name = "{0}_ashikhmin_brdf_glossy_brdf_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(glossy_brdf_reflectance_name,
                                                       asr_mat.ashikhmin_brdf_glossy,
                                                       1)
        # TODO: add texture support
        shininess_u = asr_mat.ashikhmin_brdf_shininess_u
        shininess_v = asr_mat.ashikhmin_brdf_shininess_v
        diffuse_multiplier = asr_mat.ashikhmin_brdf_multiplier
        fresnel = 1

        self.__open_element('bsdf name="{0}" model="ashikhmin_brdf"'.format(bsdf_name))
        self.__emit_parameter("diffuse_reflectance", diffuse_reflectance_name)
        self.__emit_parameter("diffuse_reflectance_multiplier", diffuse_multiplier)
        self.__emit_parameter("glossy_reflectance", glossy_brdf_reflectance_name)
        self.__emit_parameter("shininess_u", shininess_u)
        self.__emit_parameter("shininess_v", shininess_v)
        self.__emit_parameter("fresnel_multiplier", fresnel)
        self.__close_element("bsdf")

    def __emit_blinn_brdf(self, material, bsdf_name, scene, asr_mat=None):

        exponent = asr_mat.blinn_brdf_exponent
        ior = asr_mat.blinn_brdf_ior
        # check for texture in exponent slot
        if asr_mat.blinn_brdf_exponent_use_tex and asr_mat.blinn_brdf_exponent_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.blinn_brdf_exponent_tex]):
                exponent = asr_mat.blinn_brdf_exponent_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.blinn_brdf_exponent_tex], False, scene)

        self.__open_element('bsdf name="{0}" model="blinn_brdf"'.format(bsdf_name))
        self.__emit_parameter("exponent", exponent)
        self.__emit_parameter("ior", ior)
        self.__close_element("bsdf")

    def __emit_glass_bsdf(self, material, bsdf_name, scene, asr_mat=None):
        surface_transmittance = ""
        reflection_tint = ""
        refraction_tint = ""
        volume_transmittance = ""
        volume_absorption = ""

        surface_transmittance_multiplier = asr_mat.glass_bsdf_surface_transmittance_multiplier
        roughness = asr_mat.glass_bsdf_roughness
        anisotropy = asr_mat.glass_bsdf_anisotropy
        volume_transmittance_distance = asr_mat.glass_bsdf_volume_transmittance_distance
        volume_density = asr_mat.glass_bsdf_volume_density
        mdf = asr_mat.glass_bsdf_mdf
        ior = asr_mat.glass_bsdf_ior
        falloff = asr_mat.glass_bsdf_highlight_falloff
        parameterization = asr_mat.glass_bsdf_volume_parameterization
        volume_scale = asr_mat.glass_bsdf_volume_scale
        # check for texture in surface_transmittance_name slot
        if asr_mat.glass_bsdf_surface_transmittance_use_tex and asr_mat.glass_bsdf_surface_transmittance_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glass_bsdf_surface_transmittance_tex]):
                surface_transmittance = asr_mat.glass_bsdf_surface_transmittance_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glass_bsdf_surface_transmittance_tex], False, scene)
        if surface_transmittance == "":
            surface_transmittance = "{0}_surface_transmittance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(surface_transmittance,
                                                       asr_mat.glass_bsdf_surface_transmittance,
                                                       1)

        # check for texture in surface_transmittance_multiplier slot
        if asr_mat.glass_bsdf_surface_transmittance_multiplier_use_tex and asr_mat.glass_bsdf_surface_transmittance_multiplier_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glass_bsdf_surface_transmittance_multiplier_tex]):
                surface_transmittance_multiplier = asr_mat.glass_bsdf_surface_transmittance_multiplier_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glass_bsdf_surface_transmittance_multiplier_tex], False, scene)

        # check for texture in reflection_tint slot
        if asr_mat.glass_bsdf_reflection_tint_use_tex and asr_mat.glass_bsdf_reflection_tint_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glass_bsdf_reflection_tint_tex]):
                reflection_tint = asr_mat.glass_bsdf_reflection_tint_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glass_bsdf_reflection_tint_tex], False, scene)
        if reflection_tint == "":
            reflection_tint = "{0}_reflection_tint".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(reflection_tint,
                                                       asr_mat.glass_bsdf_reflection_tint,
                                                       1)

        # check for texture in refraction_tint slot
        if asr_mat.glass_bsdf_refraction_tint_use_tex and asr_mat.glass_bsdf_refraction_tint_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glass_bsdf_refraction_tint_tex]):
                refraction_tint = asr_mat.glass_bsdf_refraction_tint_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glass_bsdf_refraction_tint_tex], False, scene)
        if refraction_tint == "":
            refraction_tint = "{0}_refraction_tint".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(refraction_tint,
                                                       asr_mat.glass_bsdf_refraction_tint,
                                                       1)

        # check for texture in roughness slot
        if asr_mat.glass_bsdf_roughness_use_tex and asr_mat.glass_bsdf_roughness_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glass_bsdf_roughness_tex]):
                roughness = asr_mat.glass_bsdf_roughness_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glass_bsdf_roughness_tex], False, scene)

        # check for texture in anisotropy slot
        if asr_mat.glass_bsdf_anisotropy_use_tex and asr_mat.glass_bsdf_anisotropy_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glass_bsdf_anisotropy_tex]):
                anisotropy = asr_mat.glass_bsdf_anisotropy_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glass_bsdf_anisotropy_tex], False, scene)

        # check for texture in volume_transmittance slot
        if asr_mat.glass_bsdf_volume_transmittance_use_tex and asr_mat.glass_bsdf_volume_transmittance_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glass_bsdf_volume_transmittance_tex]):
                volume_transmittance = asr_mat.glass_bsdf_volume_transmittance_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glass_bsdf_volume_transmittance_tex], False, scene)
        if volume_transmittance == "":
            volume_transmittance = "{0}_volume_transmittance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(volume_transmittance,
                                                       asr_mat.glass_bsdf_volume_transmittance,
                                                       1)

        # check for texture in volume_transmittance_distance slot
        if asr_mat.glass_bsdf_volume_transmittance_distance_use_tex and asr_mat.glass_bsdf_volume_transmittance_distance_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glass_bsdf_volume_transmittance_distance_tex]):
                volume_transmittance_distance = asr_mat.glass_bsdf_volume_transmittance_distance_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glass_bsdf_volume_transmittance_distance_tex], False, scene)

        # check for texture in volume_absorption slot
        if asr_mat.glass_bsdf_volume_absorption_use_tex and asr_mat.glass_bsdf_volume_absorption_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glass_bsdf_volume_absorption_tex]):
                volume_absorption = asr_mat.glass_bsdf_volume_absorption_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glass_bsdf_volume_absorption_tex], False, scene)
        if volume_absorption == "":
            volume_absorption = "{0}_volume_absorption".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(volume_absorption,
                                                       asr_mat.glass_bsdf_volume_absorption,
                                                       1)

        # check for texture in volume_density slot
        if asr_mat.glass_bsdf_volume_density_use_tex and asr_mat.glass_bsdf_volume_density_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.glass_bsdf_volume_density_tex]):
                volume_density = asr_mat.glass_bsdf_volume_density_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.glass_bsdf_volume_density_tex], False, scene)

        self.__open_element('bsdf name="{0}" model="glass_bsdf"'.format(bsdf_name))
        self.__emit_parameter("mdf", mdf)
        self.__emit_parameter("surface_transmittance", surface_transmittance)
        self.__emit_parameter("surface_transmittance_multiplier", surface_transmittance_multiplier)
        self.__emit_parameter("reflection_tint", reflection_tint)
        self.__emit_parameter("refraction_tint", refraction_tint)
        self.__emit_parameter("ior", ior)
        self.__emit_parameter("roughness", roughness)
        self.__emit_parameter("highlight_falloff", falloff)
        self.__emit_parameter("anisotropy", anisotropy)
        self.__emit_parameter("volume_parameterization", parameterization)
        if parameterization == 'transmittance':
            self.__emit_parameter("volume_transmittance", volume_transmittance)
            self.__emit_parameter("volume_transmittance_distance", volume_transmittance_distance)
        else:
            self.__emit_parameter("volume_absorption", volume_absorption)
            self.__emit_parameter("volume_density", volume_density)
        self.__emit_parameter("volume_scale", volume_scale)
        self.__close_element("bsdf")

    def __emit_metal_brdf(self, material, bsdf_name, scene, asr_mat=None):
        normal_reflectance = ""
        edge_tint = ""

        reflectance_multiplier = asr_mat.metal_brdf_reflectance_multiplier
        roughness = asr_mat.metal_brdf_roughness
        anisotropy = asr_mat.metal_brdf_anisotropy
        mdf = asr_mat.metal_brdf_mdf
        highlight_falloff = asr_mat.metal_brdf_highlight_falloff
        # check for texture in normal_reflectance_name slot
        if asr_mat.metal_brdf_normal_reflectance_use_tex and asr_mat.metal_brdf_normal_reflectance_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.metal_brdf_normal_reflectance_tex]):
                normal_reflectance = asr_mat.metal_brdf_normal_reflectance_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.metal_brdf_normal_reflectance_tex], False, scene)
        if normal_reflectance == "":
            normal_reflectance = "{0}_normal_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(normal_reflectance,
                                                       asr_mat.metal_brdf_normal_reflectance,
                                                       1)

        # check for texture in edge_tint_name slot
        if asr_mat.metal_brdf_edge_tint_use_tex and asr_mat.metal_brdf_edge_tint_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.metal_brdf_edge_tint_tex]):
                edge_tint = asr_mat.metal_brdf_edge_tint_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.metal_brdf_edge_tint_tex], False, scene)
        if edge_tint == "":
            edge_tint = "{0}_edge_tint".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(edge_tint,
                                                       asr_mat.metal_brdf_edge_tint,
                                                       1)

        # check for texture in reflectance_multiplier_multiplier slot
        if asr_mat.metal_brdf_reflectance_multiplier_use_tex and asr_mat.metal_brdf_reflectance_multiplier_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.metal_brdf_reflectance_multiplier_tex]):
                reflectance_multiplier = asr_mat.metal_brdf_reflectance_multiplier_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.metal_brdf_reflectance_multiplier_tex], False, scene)

        # check for texture in roughness slot
        if asr_mat.metal_brdf_roughness_use_tex and asr_mat.metal_brdf_roughness_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.metal_brdf_roughness_tex]):
                roughness = asr_mat.metal_brdf_roughness_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.metal_brdf_roughness_tex], False, scene)

        # check for texture in anisotropy slot
        if asr_mat.metal_brdf_anisotropy_use_tex and asr_mat.metal_brdf_anisotropy_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.metal_brdf_anisotropy_tex]):
                anisotropy = asr_mat.metal_brdf_anisotropy_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.metal_brdf_anisotropy_tex], False, scene)

        self.__open_element('bsdf name="{0}" model="metal_brdf"'.format(bsdf_name))
        self.__emit_parameter("mdf", mdf)
        self.__emit_parameter("normal_reflectance", normal_reflectance)
        self.__emit_parameter("edge_tint", edge_tint)
        self.__emit_parameter("reflectance_multiplier", reflectance_multiplier)
        self.__emit_parameter("highlight_falloff", highlight_falloff)
        self.__emit_parameter("roughness", roughness)
        self.__emit_parameter("anisotropy", anisotropy)
        self.__close_element("bsdf")

    def __emit_plastic_brdf(self, material, bsdf_name, scene, asr_mat=None):
        specular_reflectance = ""
        diffuse_reflectance = ""

        mdf = asr_mat.plastic_brdf_mdf
        ior = asr_mat.plastic_brdf_ior
        falloff = asr_mat.plastic_brdf_highlight_falloff
        specular_reflectance_multiplier = asr_mat.plastic_brdf_specular_reflectance_multiplier
        roughness = asr_mat.plastic_brdf_roughness
        diffuse_reflectance_multiplier = asr_mat.plastic_brdf_diffuse_reflectance_multiplier

        # check for texture in specular_reflectance slot
        if asr_mat.plastic_brdf_specular_reflectance_use_tex and asr_mat.plastic_brdf_specular_reflectance_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.plastic_brdf_specular_reflectance_tex]):
                specular_reflectance = asr_mat.plastic_brdf_specular_reflectance_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.plastic_brdf_specular_reflectance_tex], False, scene)
        if specular_reflectance == "":
            specular_reflectance = "{0}_specular_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(specular_reflectance,
                                                       asr_mat.plastic_brdf_specular_reflectance,
                                                       1)

        # check for texture in specular_reflectance_multiplier slot
        if asr_mat.plastic_brdf_specular_reflectance_multiplier_use_tex and asr_mat.plastic_brdf_specular_reflectance_multiplier_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.plastic_brdf_specular_reflectance_multiplier_tex]):
                specular_reflectance_multiplier = asr_mat.plastic_brdf_specular_reflectance_multiplier_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.plastic_brdf_specular_reflectance_multiplier_tex], False, scene)

        # check for texture in roughness slot
        if asr_mat.plastic_brdf_roughness_use_tex and asr_mat.plastic_brdf_roughness_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.plastic_brdf_roughness_tex]):
                roughness = asr_mat.plastic_brdf_roughness_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.plastic_brdf_roughness_tex], False, scene)

        # check for texture in diffuse_reflectance slot
        if asr_mat.plastic_brdf_diffuse_reflectance_use_tex and asr_mat.plastic_brdf_diffuse_reflectance_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.plastic_brdf_diffuse_reflectance_tex]):
                diffuse_reflectance = asr_mat.plastic_brdf_diffuse_reflectance_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.plastic_brdf_diffuse_reflectance_tex], False, scene)
        if diffuse_reflectance == "":
            diffuse_reflectance = "{0}_diffuse_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(diffuse_reflectance,
                                                       asr_mat.plastic_brdf_diffuse_reflectance,
                                                       1)

        # check for texture in diffuse_reflectance_multiplier slot
        if asr_mat.plastic_brdf_diffuse_reflectance_multiplier_use_tex and asr_mat.plastic_brdf_diffuse_reflectance_multiplier_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.plastic_brdf_diffuse_reflectance_multiplier_tex]):
                diffuse_reflectance_multiplier = asr_mat.plastic_brdf_diffuse_reflectance_multiplier_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.plastic_brdf_diffuse_reflectance_multiplier_tex], False, scene)

        self.__open_element('bsdf name="{0}" model="plastic_brdf"'.format(bsdf_name))
        self.__emit_parameter("mdf", mdf)
        self.__emit_parameter("specular_reflectance", specular_reflectance)
        self.__emit_parameter("specular_reflectance_multiplier", specular_reflectance_multiplier)
        self.__emit_parameter("roughness", roughness)
        self.__emit_parameter("highlight_falloff", falloff)
        self.__emit_parameter("ior", ior)
        self.__emit_parameter("diffuse_reflectance", diffuse_reflectance)
        self.__emit_parameter("diffuse_reflectance_multiplier", diffuse_reflectance_multiplier)
        self.__close_element("bsdf")

    def __emit_specular_brdf(self, material, bsdf_name, scene, asr_mat=None):
        reflectance_name = ""

        if asr_mat.specular_brdf_use_glossy_tex and asr_mat.specular_brdf_glossy_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.specular_brdf_glossy_tex]):
                reflectance_name = asr_mat.specular_brdf_glossy_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.specular_brdf_glossy_tex], False, scene)
        if reflectance_name == "":
            reflectance_name = "{0}_specular_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(reflectance_name,
                                                       asr_mat.specular_brdf_reflectance,
                                                       1)
        # TODO: add texture support for multiplier
        multiplier = asr_mat.specular_brdf_multiplier

        self.__open_element('bsdf name="{0}" model="specular_brdf"'.format(bsdf_name))
        self.__emit_parameter("reflectance", reflectance_name)
        self.__emit_parameter("reflectance_multiplier", multiplier)
        self.__close_element("bsdf")

    def __emit_specular_btdf(self, material, bsdf_name, scene, asr_mat=None):
        reflectance_name = ""
        transmittance_name = ""

        if asr_mat.specular_btdf_use_specular_tex and asr_mat.specular_btdf_specular_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.specular_btdf_specular_tex]):
                reflectance_name = asr_mat.specular_btdf_specular_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.specular_btdf_specular_tex], False, scene)

        if reflectance_name == "":
            reflectance_name = "{0}_transp_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(reflectance_name,
                                                       asr_mat.specular_btdf_reflectance,
                                                       1)

        if asr_mat.specular_btdf_use_trans_tex and asr_mat.specular_btdf_trans_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.specular_btdf_trans_tex]):
                transmittance_name = asr_mat.specular_btdf_trans_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.specular_btdf_trans_tex], False, scene)

        if transmittance_name == "":
            transmittance_name = "{0}_transp_transmittance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(transmittance_name,
                                                       asr_mat.specular_btdf_transmittance,
                                                       1)
        # TODO: add texture support for multiplier
        reflectance_multiplier = asr_mat.specular_btdf_refl_mult
        transmittance_multiplier = asr_mat.specular_btdf_trans_mult

        fresnel_multiplier = asr_mat.specular_btdf_fresnel_multiplier

        if asr_mat.specular_btdf_fresnel_multiplier_use_tex and asr_mat.specular_btdf_fresnel_multiplier_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.specular_btdf_fresnel_multiplier_tex]):
                fresnel_multiplier = asr_mat.specular_btdf_fresnel_multiplier_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.specular_btdf_fresnel_multiplier_tex], False, scene)

        ior = asr_mat.specular_btdf_ior
        volume_density = asr_mat.specular_btdf_volume_density
        volume_scale = asr_mat.specular_btdf_volume_scale

        self.__open_element('bsdf name="{0}" model="specular_btdf"'.format(bsdf_name))
        self.__emit_parameter("reflectance", reflectance_name)
        self.__emit_parameter("reflectance_multiplier", reflectance_multiplier)
        self.__emit_parameter("transmittance", transmittance_name)
        self.__emit_parameter("transmittance_multiplier", transmittance_multiplier)
        self.__emit_parameter("fresnel_multiplier", fresnel_multiplier)
        self.__emit_parameter("ior", ior)
        self.__emit_parameter("volume_density", volume_density)
        self.__emit_parameter("volume_scale", volume_scale)
        self.__close_element("bsdf")

    def __emit_kelemen_brdf(self, material, bsdf_name, scene, asr_mat=None):
        reflectance_name = ""
        specular_refl_name = ""

        if asr_mat.kelemen_brdf_use_diffuse_tex and asr_mat.kelemen_brdf_diffuse_tex != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.kelemen_brdf_diffuse_tex]):
                reflectance_name = asr_mat.kelemen_brdf_diffuse_tex + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.kelemen_brdf_diffuse_tex], False, scene)

        if reflectance_name == "":
            reflectance_name = "{0}_kelemen_brdf_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(reflectance_name,
                                                       asr_mat.kelemen_brdf_matte_reflectance,
                                                       1)

        kelemen_brdf_roughness = asr_mat.kelemen_brdf_roughness
        kelemen_brdf_specular_multiplier = asr_mat.kelemen_brdf_specular_multiplier
        kelemen_brdf_specular_reflectance = asr_mat.kelemen_brdf_specular_reflectance
        kelemen_brdf_matte_multiplier = asr_mat.kelemen_brdf_matte_multiplier

        self.__open_element('bsdf name="{0}" model="kelemen_brdf"'.format(bsdf_name))
        self.__emit_parameter("matte_reflectance", reflectance_name)
        self.__emit_parameter("matte_reflectance_multiplier", kelemen_brdf_matte_multiplier)
        self.__emit_parameter("roughness", kelemen_brdf_roughness)
        self.__emit_parameter("specular_reflectance", kelemen_brdf_specular_reflectance)
        self.__emit_parameter("specular_reflectance_multiplier", kelemen_brdf_specular_multiplier)
        self.__close_element("bsdf")

    def __emit_bssrdf(self, material, bsdf_name, scene):
        bssrdf_reflectance = ""
        bssrdf_mfp = ""

        asr_mat = material.appleseed
        if asr_mat.bssrdf_reflectance_use_texture and asr_mat.bssrdf_reflectance_texture != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.bssrdf_reflectance_texture]):
                bssrdf_reflectance = asr_mat.bssrdf_reflectance_texture + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.bssrdf_reflectance_texture], False, scene)

        if bssrdf_reflectance == "":
            bssrdf_reflectance = "{0}_bssrdf_reflectance".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(bssrdf_reflectance,
                                                       asr_mat.bssrdf_reflectance,
                                                       1)

        if asr_mat.bssrdf_mfp_use_texture and asr_mat.bssrdf_mfp_texture != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.bssrdf_mfp_texture]):
                bssrdf_mfp_name = asr_mat.bssrdf_mfp_texture + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.bssrdf_mfp_texture], False, scene)

        if bssrdf_mfp == "":
            bssrdf_mfp = "{0}_bssrdf_mfp".format(bsdf_name)
            self.__emit_solid_linear_rgb_color_element(bssrdf_mfp,
                                                       asr_mat.bssrdf_mfp,
                                                       1)

        bssrdf_reflectance_multiplier = asr_mat.bssrdf_reflectance_multiplier

        if asr_mat.bssrdf_reflectance_multiplier_use_texture and asr_mat.bssrdf_reflectance_multiplier_texture != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.bssrdf_reflectance_multiplier_texture]):
                bssrdf_reflectance_multiplier = asr_mat.bssrdf_reflectance_multiplier_texture + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.bssrdf_reflectance_multiplier_texture], False, scene)

        bssrdf_mfp_multiplier = asr_mat.bssrdf_mfp_multiplier

        if asr_mat.bssrdf_mfp_multiplier_use_texture and asr_mat.bssrdf_mfp_multiplier_texture != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.bssrdf_mfp_multiplier_texture]):
                bssrdf_mfp_multiplier = asr_mat.bssrdf_mfp_multiplier_texture + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.bssrdf_mfp_multiplier_texture], False, scene)

        bssrdf_weight = asr_mat.bssrdf_weight

        if asr_mat.bssrdf_weight_use_texture and asr_mat.bssrdf_weight_texture != "":
            if util.is_uv_img(bpy.data.textures[asr_mat.bssrdf_weight_texture]):
                bssrdf_weight = asr_mat.bssrdf_weight_texture + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.bssrdf_weight_texture], False, scene)

        bssrdf_ior = asr_mat.bssrdf_ior
        bssrdf_fresnel_weight = asr_mat.bssrdf_fresnel_weight
        bssrdf_model = asr_mat.bssrdf_model

        self.__open_element('bssrdf name="{0}" model="{1}"'.format(bsdf_name, bssrdf_model))
        self.__emit_parameter("weight", bssrdf_weight)
        self.__emit_parameter("reflectance", bssrdf_reflectance)
        self.__emit_parameter("reflectance_multiplier", bssrdf_reflectance_multiplier)
        self.__emit_parameter("mfp", bssrdf_mfp)
        self.__emit_parameter("mfp_multiplier", bssrdf_mfp_multiplier)
        self.__emit_parameter("ior", bssrdf_ior)
        self.__emit_parameter("fresnel_weight", bssrdf_fresnel_weight)
        self.__close_element("bssrdf")

    def __emit_volume(self, material, volume_name, scene):
        volume_absorption_name = "{0}_volume_absorption".format(volume_name)
        volume_scattering_name = "{0}_volume_scattering".format(volume_name)

        asr_mat = material.appleseed
        volume_absorption = asr_mat.volume_absorption
        volume_absorption_multiplier = asr_mat.volume_absorption_multiplier
        volume_scattering = asr_mat.volume_scattering
        volume_scattering_multiplier = asr_mat.volume_scattering_multiplier
        volume_phase_function_model = asr_mat.volume_phase_function_model
        volume_average_cosine = asr_mat.volume_average_cosine

        self.__emit_solid_linear_rgb_color_element(volume_absorption_name,
                                                   volume_absorption,
                                                   1)
        self.__emit_solid_linear_rgb_color_element(volume_scattering_name,
                                                   volume_scattering,
                                                   1)

        self.__open_element('volume name="{0}" model="generic_volume"'.format(volume_name))
        self.__emit_parameter("absorption", volume_absorption_name)
        self.__emit_parameter("absorption_multiplier", volume_absorption_multiplier)
        self.__emit_parameter("scattering", volume_scattering_name)
        self.__emit_parameter("scattering_multiplier", volume_scattering_multiplier)
        self.__emit_parameter("phase_function_model", volume_phase_function_model)
        if volume_phase_function_model == 'henyey':
            self.__emit_parameter("average_cosine", volume_average_cosine)
        self.__close_element("volume")

    def __emit_edf(self, material, edf_name, scene):
        """Writes the emissive component of a material."""

        asr_mat = material.appleseed

        radiance = "{0}_radiance".format(edf_name)
        model = asr_mat.light_emission_profile
        angle = asr_mat.light_cone_edf_angle
        radiance_multiplier = asr_mat.light_emission
        cast_indirect = str(asr_mat.cast_indirect).lower()
        importance_multiplier = asr_mat.importance_multiplier
        exposure = asr_mat.light_exposure
        light_near_start = asr_mat.light_near_start
        self.__emit_solid_linear_rgb_color_element(radiance,
                                                   asr_mat.light_color,
                                                   scene.appleseed.light_mats_radiance_multiplier)

        self.__open_element('edf name="{0}" model="{1}"'.format(edf_name, model))
        self.__emit_parameter("radiance", radiance)
        if model == 'cone_edf':
            self.__emit_parameter("angle", angle)
        self.__emit_parameter("radiance_multiplier", radiance_multiplier)
        self.__emit_parameter("cast_indirect_light", cast_indirect)
        self.__emit_parameter("exposure", exposure)
        self.__emit_parameter("importance_multiplier", importance_multiplier)
        self.__emit_parameter("light_near_start", light_near_start)
        self.__close_element("edf")

    def __emit_texture(self, texture, bump_bool, scene, material_name=None, scene_texture=False, object=None):
        """Emits a reference to a texture file."""

        # Nothing to do if this texture was already emitted.

        if texture in self._textures_set:
            return

        self._textures_set.add(texture)

        if scene_texture:
            # texture is an absolute file path string.
            # Assume the path ends with '.png' or '.exr'.
            texture_name = texture.split(util.sep)[-1][:-4]
            filepath = texture
            color_space = 'srgb'
        elif object is not None:
            filepath = util.realpath(object.appleseed.object_alpha_texture)
            texture_name = object.name + "_alpha"
            color_space = object.appleseed.object_alpha_texture_colorspace
        else:
            if texture.image.colorspace_settings.name == 'Linear':
                color_space = 'linear_rgb'
            elif texture.image.colorspace_settings.name == 'XYZ':
                color_space = 'ciexyz'
            else:
                color_space = 'srgb'

            filepath = util.realpath(texture.image.filepath)
            texture_name = texture.name

        self.__open_element('texture name="{0}" model="disk_texture_2d"'.format(texture_name))
        self.__emit_parameter("color_space", color_space)
        self.__emit_parameter("filename", filepath)
        self.__close_element("texture")

        # Now create texture instance.
        self.__emit_texture_instance(texture, texture_name, bump_bool, material_name, scene_texture, object)

    def __emit_texture_instance(self, texture, texture_name, bump_bool, material_name=None, scene_texture=False, object=None):
        """Write the instance for the texture"""

        if scene_texture:
            mode = "clamp"
        elif object is not None:
            mode = object.appleseed.object_alpha_texture_wrap_mode
        else:
            mode = "wrap" if texture.extension == "REPEAT" else "clamp"

        self.__open_element('texture_instance name="{0}_inst" texture="{1}"'.format(texture_name, texture_name))
        self.__emit_parameter("addressing_mode", mode)
        self.__emit_parameter("filtering_mode", "bilinear")
        self.__emit_parameter("alpha_mode", "detect")
        self.__close_element("texture_instance")

    def __emit_osl_element(self, front_material_name, surface_name):
        self.__open_element('material name="{0}" model="osl_material"'.format(front_material_name))
        self.__emit_parameter("surface_shader", "physical_surface_shader")
        self.__emit_parameter("osl_surface", surface_name)
        self.__close_element("material")

    def __emit_material_element(self, material_name, bsdf_name, edf_name, bssrdf_name, volume_name, surface_shader_name, scene, material):
        """This writes the material definition."""

        if material != "":
            asr_mat = material.appleseed
        bump_map = ""
        material_alpha_map = 1.0
        material_bump_amplitude = 1.0
        method = "bump"

        # Check whether evaluating default material.
        if material != "":
            if asr_mat.material_use_alpha and asr_mat.material_alpha_map != "":
                if util.is_uv_img(bpy.data.textures[asr_mat.material_alpha_map]):
                    material_alpha_map = asr_mat.material_alpha_map + "_inst"
                    self.__emit_texture(bpy.data.textures[asr_mat.material_alpha_map], False, scene)

            if asr_mat.material_use_bump_tex:
                if asr_mat.material_bump_tex != "":
                    if util.is_uv_img(bpy.data.textures[asr_mat.material_bump_tex]):
                        bump_map = asr_mat.material_bump_tex

            if bump_map != "":
                self.__emit_texture(bpy.data.textures[asr_mat.material_bump_tex], True, scene)
                material_bump_amplitude = asr_mat.material_bump_amplitude
                bump_map += "_inst"
                method = "normal" if asr_mat.material_use_normalmap else "bump"

            if asr_mat.material_use_alpha and asr_mat.material_alpha_map != "":
                material_alpha_map = asr_mat.material_alpha_map + "_inst"
                self.__emit_texture(bpy.data.textures[asr_mat.material_alpha_map], False, scene)
            else:
                material_alpha_map = asr_mat.material_alpha

        self.__open_element('material name="{0}" model="generic_material"'.format(material_name))
        if bsdf_name:
            self.__emit_parameter("bsdf", bsdf_name)
        if bssrdf_name:
            self.__emit_parameter("bssrdf", bssrdf_name)
        if len(edf_name) > 0:
            self.__emit_parameter("edf", edf_name)
        if len(volume_name) > 0:
            self.__emit_parameter("volume", volume_name)

        if bump_map != "":
            self.__emit_parameter("displacement_map", bump_map)
            self.__emit_parameter("bump_amplitude", material_bump_amplitude)
            if method == "bump":
                self.__emit_parameter("bump_offset", asr_mat.material_bump_offset)
            else:
                self.__emit_parameter("normal_map_up", "z")
        if material_alpha_map != 1.0:
            self.__emit_parameter("alpha_map", material_alpha_map)
        self.__emit_parameter("displacement_method", method)
        self.__emit_parameter("surface_shader", surface_shader_name)
        self.__close_element("material")

    def __emit_camera(self, scene):
        """Emit the camera into the scene file."""

        asr_scn = scene.appleseed
        shutter_open = asr_scn.shutter_open if asr_scn.enable_motion_blur else 0
        shutter_close = asr_scn.shutter_close if asr_scn.enable_motion_blur else 1
        camera = scene.camera
        width = scene.render.resolution_x
        height = scene.render.resolution_y
        emit_diaphragm_map = False
        appleseed_cam = camera.data.appleseed

        if camera is None:
            self.__warning("No camera in the scene, exporting a default camera.")
            self.__emit_default_camera_element()
            return

        render = scene.render

        film_width = camera.data.sensor_width / 1000
        ortho_width = camera.data.ortho_scale
        aspect_ratio = self.__get_frame_aspect_ratio(render)

        # Blender's camera focal length is expressed in mm
        fov = util.calc_fov(camera, width, height)

        # Camera type
        if camera.data.type == 'PERSP':
            cam_model = 'pinhole'
        elif camera.data.type == 'ORTHO':
            cam_model = 'orthographic'
        else:
            cam_model = 'spherical'

        # Test if using focal object, get focal distance.
        if cam_model == 'pinhole' and appleseed_cam.enable_dof:
            cam_model = 'thinlens'
            if camera.data.dof_object is not None:
                cam_target = bpy.data.objects[camera.data.dof_object.name]
                focal_distance = (cam_target.location - camera.location).magnitude
            else:
                focal_distance = camera.data.dof_distance

        self.__open_element('camera name="{0}" model="{1}_camera"'.format(camera.name, cam_model))
        if cam_model == "thinlens":
            self.__emit_parameter("f_stop", appleseed_cam.f_number)
            self.__emit_parameter("autofocus_enabled", "false")
            self.__emit_parameter("focal_distance", focal_distance)
            self.__emit_parameter("diaphragm_blades", appleseed_cam.diaphragm_blades)
            self.__emit_parameter("diaphragm_tilt_angle", appleseed_cam.diaphragm_angle)
            emit_diaphragm_map = False
            if appleseed_cam.diaphragm_map != '' and appleseed_cam.diaphragm_map[-3:] in {'png', 'exr'}:
                emit_diaphragm_map = True
                texture_name = appleseed_cam.diaphragm_map.split(util.sep)[-1][:-4]
                self.__emit_parameter("diaphragm_map", texture_name + "_inst")
        if cam_model != 'spherical':
            self.__emit_parameter("aspect_ratio", aspect_ratio)
            if cam_model == 'orthographic':
                self.__emit_parameter("film_width", ortho_width)
            else:
                self.__emit_parameter("film_width", film_width)
                self.__emit_parameter("horizontal_fov", fov)
        self.__emit_parameter("shutter_open_time", shutter_open)
        self.__emit_parameter("shutter_close_time", shutter_close)
        self.__emit_parameter("near_z", appleseed_cam.near_z)

        current_frame = scene.frame_current
        scene.frame_set(current_frame, subframe=shutter_open)
        origin_1, forward_1, up_1, target_1 = util.get_camera_matrix(camera, self._global_matrix)

        # Write respective transforms if using camera motion blur.
        if scene.appleseed.enable_motion_blur and scene.appleseed.enable_camera_blur:
            scene.frame_set(current_frame, subframe=asr_scn.shutter_close)
            origin_2, forward_2, up_2, target_2 = util.get_camera_matrix(camera, self._global_matrix)
            # Return the timeline to original frame.
            scene.frame_set(current_frame)

            self.__open_element('transform time="0"')
            self.__emit_line('<look_at origin="{0} {1} {2}" target="{3} {4} {5}" up="{6} {7} {8}" />'.format(
                origin_1[0], origin_1[2], -origin_1[1],
                target_1[0], target_1[2], -target_1[1],
                up_1[0], up_1[2], -up_1[1]))
            self.__close_element("transform")

            self.__open_element('transform time="1"')
            self.__emit_line('<look_at origin="{0} {1} {2}" target="{3} {4} {5}" up="{6} {7} {8}" />'.format(
                origin_2[0], origin_2[2], -origin_2[1],
                target_2[0], target_2[2], -target_2[1],
                up_2[0], up_2[2], -up_2[1]))
            self.__close_element("transform")
        else:
            self.__open_element("transform")
            self.__emit_line('<look_at origin="{0} {1} {2}" target="{3} {4} {5}" up="{6} {7} {8}" />'.format(
                origin_1[0], origin_1[2], -origin_1[1],
                target_1[0], target_1[2], -target_1[1],
                up_1[0], up_1[2], -up_1[1]))
            self.__close_element("transform")

        self.__close_element("camera")

        # Write diaphragm texture to Scene, if enabled.
        if emit_diaphragm_map:
            self.__emit_texture(util.realpath(appleseed_cam.diaphragm_map), False, scene, scene_texture=True)

    def __emit_default_camera_element(self):
        """If no camera is defined in the Blender scene, this default is exported."""

        self.__open_element('camera name="camera" model="pinhole_camera"')
        self.__emit_parameter("film_width", 0.024892)
        self.__emit_parameter("film_height", 0.018669)
        self.__emit_parameter("focal_length", 0.035)
        self.__close_element("camera")
        return

    def __emit_environment(self, scene):
        horizon_radiance = [0.0, 0.0, 0.0]
        zenith_radiance = [0.0, 0.0, 0.0]

        # Add the contribution of the sky.
        if scene.world is not None:
            horizon_radiance = add(horizon_radiance, scene.world.horizon_color)
            zenith_radiance = add(zenith_radiance, scene.world.zenith_color)

        # Write the environment EDF and environment shader if necessary.
        if is_black(horizon_radiance) and is_black(zenith_radiance) and not scene.appleseed_sky.env_type == "sunsky":
            env_edf_name = ""
            env_shader_name = ""
        else:
            # Write the radiances.
            self.__emit_solid_linear_rgb_color_element("horizon_radiance", horizon_radiance, 1)
            self.__emit_solid_linear_rgb_color_element("zenith_radiance", zenith_radiance, 1)

            # Write the environment EDF.
            env_edf_name = "environment_edf"
            if scene.appleseed_sky.env_type == "gradient":
                self.__open_element('environment_edf name="{0}" model="gradient_environment_edf"'.format(env_edf_name))
                self.__emit_parameter("horizon_radiance", "horizon_radiance")
                self.__emit_parameter("zenith_radiance", "zenith_radiance")
                self.__close_element('environment_edf')

            elif scene.appleseed_sky.env_type == "constant":
                self.__open_element('environment_edf name="{0}" model="constant_environment_edf"'.format(env_edf_name))
                self.__emit_parameter("radiance", "horizon_radiance")
                self.__close_element('environment_edf')

            elif scene.appleseed_sky.env_type == "constant_hemisphere":
                self.__open_element('environment_edf name="{0}" model="constant_hemisphere_environment_edf"'.format(env_edf_name))
                self.__emit_parameter("lower_hemi_radiance", "horizon_radiance")
                self.__emit_parameter("upper_hemi_radiance", "zenith_radiance")
                self.__close_element('environment_edf')

            elif scene.appleseed_sky.env_type == "mirrorball_map":
                if scene.appleseed_sky.env_tex != "":
                    self.__emit_texture(bpy.data.textures[scene.appleseed_sky.env_tex], False, scene)
                    self.__open_element('environment_edf name="{0}" model="mirrorball_map_environment_edf"'.format(env_edf_name))
                    self.__emit_parameter("radiance", scene.appleseed_sky.env_tex + "_inst")
                    self.__emit_parameter("radiance_multiplier", scene.appleseed_sky.env_tex_mult)
                    self.__close_element('environment_edf')
                else:
                    self.__warning("Mirror Ball environment texture is enabled, but no texture is assigned. Using gradient environment.")
                    self.__open_element('environment_edf name="{0}" model="gradient_environment_edf"'.format(env_edf_name))
                    self.__emit_parameter("horizon_radiance", "horizon_radiance")
                    self.__emit_parameter("zenith_radiance", "zenith_radiance")
                    self.__close_element('environment_edf')

            elif scene.appleseed_sky.env_type == "latlong_map":
                if scene.appleseed_sky.env_tex != "":
                    self.__emit_texture(bpy.data.textures[scene.appleseed_sky.env_tex], False, scene)
                    self.__open_element('environment_edf name="{0}" model="latlong_map_environment_edf"'.format(env_edf_name))
                    self.__emit_parameter("radiance", scene.appleseed_sky.env_tex + "_inst")
                    self.__emit_parameter("radiance_multiplier", scene.appleseed_sky.env_tex_mult)
                    self.__emit_parameter("exposure", scene.appleseed_sky.env_exposure)
                    self.__emit_parameter("vertical_shift", scene.appleseed_sky.vertical_shift)
                    self.__emit_parameter("horizontal_shift", scene.appleseed_sky.horizontal_shift)
                    self.__close_element('environment_edf')
                else:
                    self.__warning("Latitude-Longitude environment texture is enabled, but no texture is assigned. Using gradient environment.")
                    self.__open_element('environment_edf name="{0}" model="gradient_environment_edf"'.format(env_edf_name))
                    self.__emit_parameter("horizon_radiance", "horizon_radiance")
                    self.__emit_parameter("zenith_radiance", "zenith_radiance")
                    self.__close_element('environment_edf')

            elif scene.appleseed_sky.env_type == "sunsky":
                asr_sky = scene.appleseed_sky
                self.__open_element('environment_edf name="{0}" model="{1}"'.format(env_edf_name, asr_sky.sun_model))
                if asr_sky.sun_model == "hosek_environment_edf":
                    self.__emit_parameter("ground_albedo", asr_sky.ground_albedo)
                self.__emit_parameter("sun_phi", asr_sky.sun_phi)
                self.__emit_parameter("sun_theta", asr_sky.sun_theta)
                self.__emit_parameter("turbidity", asr_sky.turbidity)
                self.__emit_parameter("turbidity_multiplier", asr_sky.turbidity_multiplier)
                self.__emit_parameter("luminance_multiplier", asr_sky.luminance_multiplier)
                self.__emit_parameter("luminance_gamma", asr_sky.luminance_gamma)
                self.__emit_parameter("saturation_multiplier", asr_sky.saturation_multiplier)
                self.__emit_parameter("horizon_shift", asr_sky.horizon_shift)
                self.__close_element('environment_edf')

            # Write the environment shader.
            env_shader_name = "environment_shader"
            self.__open_element('environment_shader name="{0}" model="edf_environment_shader"'.format(env_shader_name))
            self.__emit_parameter("environment_edf", env_edf_name)
            self.__emit_parameter("alpha_value", scene.appleseed_sky.env_alpha)
            self.__close_element('environment_shader')

        # Write the environment element.
        self.__open_element('environment name="environment" model="generic_environment"')
        if len(env_edf_name) > 0:
            self.__emit_parameter("environment_edf", env_edf_name)
        if len(env_shader_name) > 0:
            self.__emit_parameter("environment_shader", env_shader_name)
        self.__close_element('environment')

    def __emit_light(self, scene, object):
        """This determines what export function to call based on what the light type is."""

        light_type = object.data.type

        if light_type == 'POINT':
            self.__emit_point_light(scene, object)
        elif light_type == 'SPOT':
            self.__emit_spot_light(scene, object)
        elif light_type == 'HEMI':
            self.__emit_directional_light(scene, object)
        elif light_type == 'SUN' and scene.appleseed_sky.env_type == "sunsky":
            self.__emit_sun_light(scene, object)
        elif light_type == 'SUN' and not scene.appleseed_sky.env_type == "sunsky":
            self.__warning("Sun lamp '{0}' exists in the scene, but sun/sky is not enabled".format(object.name))
            self.__emit_sun_light(scene, object)
        else:
            self.__warning("While exporting light '{0}': unsupported light type '{1}', skipping this light.".format(object.name, light_type))

    def __emit_sun_light(self, scene, lamp):
        """Emits a sun lamp into the scene file."""

        lamp_data = lamp.data
        asr_light = lamp_data.appleseed
        sunsky = scene.appleseed_sky
        use_sunsky = asr_light.use_edf
        environment_edf = "environment_edf"

        self.__open_element('light name="{0}" model="sun_light"'.format(lamp.name))
        if use_sunsky:
            self.__emit_parameter("environment_edf", environment_edf)
        self.__emit_parameter("size_multiplier", asr_light.size_multiplier)
        self.__emit_parameter("distance", asr_light.distance)
        self.__emit_parameter("radiance_multiplier", asr_light.radiance_multiplier)
        self.__emit_parameter("turbidity", sunsky.turbidity if use_sunsky else asr_light.turbidity)
        self.__emit_parameter("cast_indirect_light", str(asr_light.cast_indirect).lower())
        self.__emit_parameter("importance_multiplier", asr_light.importance_multiplier)
        self.__emit_transform_element(self._global_matrix * lamp.matrix_world, None)
        self.__close_element("light")

    def __emit_point_light(self, scene, lamp):
        """Emits a point light into the scene file"""

        lamp_data = lamp.data
        asr_light = lamp_data.appleseed
        intensity_name = "{0}_intensity".format(lamp.name)

        self.__emit_solid_linear_rgb_color_element(intensity_name, asr_light.radiance, 1)

        self.__open_element('light name="{0}" model="point_light"'.format(lamp.name))
        self.__emit_parameter("intensity", intensity_name)
        self.__emit_parameter("intensity_multiplier", asr_light.radiance_multiplier)
        self.__emit_parameter("exposure", asr_light.exposure)
        self.__emit_parameter("cast_indirect_light", str(asr_light.cast_indirect).lower())
        self.__emit_parameter("importance_multiplier", asr_light.importance_multiplier)
        self.__emit_transform_element(self._global_matrix * lamp.matrix_world, None)
        self.__close_element("light")

    def __emit_spot_light(self, scene, lamp):
        """Emits a spot lamp into the scene file."""

        lamp_data = lamp.data
        asr_light = lamp_data.appleseed

        # Radiance.
        intensity_name = "{0}_intensity".format(lamp.name)
        if asr_light.radiance_use_tex and asr_light.radiance_tex != '':
            intensity_name = asr_light.radiance_tex + "_inst"
            self.__emit_texture(bpy.data.textures[asr_light.radiance_tex], False, scene)
        else:
            self.__emit_solid_linear_rgb_color_element(intensity_name, asr_light.radiance, 1)

        # Radiance multiplier.
        intensity_multiplier = asr_light.radiance_multiplier
        if asr_light.radiance_multiplier_use_tex and asr_light.radiance_multiplier_tex != '':
            intensity_multiplier = asr_light.radiance_multiplier_tex + "_inst"
            self.__emit_texture(bpy.data.textures[asr_light.radiance_multiplier_tex], False, scene)

        # Spot cone.
        outer_angle = math.degrees(lamp.data.spot_size)
        inner_angle = (1.0 - lamp.data.spot_blend) * outer_angle

        self.__open_element('light name="{0}" model="spot_light"'.format(lamp.name))
        self.__emit_parameter("intensity", intensity_name)
        self.__emit_parameter("intensity_multiplier", intensity_multiplier)
        self.__emit_parameter("exposure", asr_light.exposure)
        self.__emit_parameter("inner_angle", inner_angle)
        self.__emit_parameter("outer_angle", outer_angle)
        self.__emit_parameter("cast_indirect_light", str(asr_light.cast_indirect).lower())
        self.__emit_parameter("importance_multiplier", asr_light.importance_multiplier)
        self.__emit_transform_element(self._global_matrix * lamp.matrix_world, None)
        self.__close_element("light")

    def __emit_directional_light(self, scene, lamp):
        """This emits a directional light into the scene file."""

        lamp_data = lamp.data
        asr_light = lamp_data.appleseed
        radiance_name = "{0}_radiance".format(lamp.name)

        self.__emit_solid_linear_rgb_color_element(radiance_name, asr_light.radiance, 1)

        self.__open_element('light name="{0}" model="directional_light"'.format(lamp.name))
        self.__emit_parameter("irradiance", radiance_name)
        self.__emit_parameter("irradiance_multiplier", asr_light.radiance_multiplier)
        self.__emit_parameter("exposure", asr_light.exposure)
        self.__emit_parameter("cast_indirect_light", str(asr_light.cast_indirect).lower())
        self.__emit_parameter("importance_multiplier", asr_light.importance_multiplier)
        self.__emit_transform_element(self._global_matrix * lamp.matrix_world, None)
        self.__close_element("light")

    def __emit_output(self, scene):
        """This writes the output section of the scene file"""

        self.__open_element("output")
        self.__emit_frame_element(scene)
        self.__close_element("output")

    def __emit_frame_element(self, scene):
        camera = scene.camera
        width, height = self.__get_frame_resolution(scene.render)
        self.__open_element("frame name=\"beauty\"")
        self.__emit_parameter("camera", "camera" if camera is None else camera.name)
        self.__emit_parameter("resolution", "{0} {1}".format(width, height))
        self.__emit_parameter("tile_size", "{0} {1}".format(scene.appleseed.tile_width, scene.appleseed.tile_height))
        self.__emit_parameter("filter", scene.appleseed.pixel_filter)
        self.__emit_parameter("filter_size", scene.appleseed.pixel_filter_size)
        if scene.appleseed.enable_render_stamp:
            self.__emit_parameter("enable_render_stamp", "true")
            self.__emit_parameter("render_stamp_format", scene.appleseed.render_stamp)
        if scene.appleseed.denoise_mode != 'off':
            self.__emit_parameter("denoiser", scene.appleseed.denoise_mode)
            self.__emit_parameter("denoise_scales", scene.appleseed.denoise_scales)
            self.__emit_parameter("patch_distance_threshold", scene.appleseed.patch_distance_threshold)
            self.__emit_parameter("prefilter_spikes", "true" if scene.appleseed.prefilter_spikes else "false")
            self.__emit_parameter("spike_threshold", scene.appleseed.spike_threshold)
        if scene.render.use_border:
            min_x, min_y, max_x, max_y = self.__get_border_limits(scene, width, height)
            self.__emit_parameter("crop_window", "{0} {1} {2} {3}".format(min_x, min_y, max_x, max_y))
        if scene.appleseed.enable_aovs:
            self.__emit_aovs(scene)
        self.__close_element("frame")

    def __emit_aovs(self, scene):
        asr_scene_props = scene.appleseed

        self.__open_element("aovs")

        if asr_scene_props.diffuse_aov:
            self.__emit_line('<aov model="diffuse_aov" />')
        if asr_scene_props.direct_diffuse_aov:
            self.__emit_line('<aov model="direct_diffuse_aov" />')
        if asr_scene_props.indirect_diffuse_aov:
            self.__emit_line('<aov model="indirect_diffuse_aov" />')
        if asr_scene_props.glossy_aov:
            self.__emit_line('<aov model="glossy_aov" />')
        if asr_scene_props.direct_glossy_aov:
            self.__emit_line('<aov model="direct_glossy_aov" />')
        if asr_scene_props.indirect_glossy_aov:
            self.__emit_line('<aov model="indirect_glossy_aov" />')
        if asr_scene_props.normal_aov:
            self.__emit_line('<aov model="normal_aov" />')
        if asr_scene_props.uv_aov:
            self.__emit_line('<aov model="uv_aov" />')
        if asr_scene_props.depth_aov:
            self.__emit_line('<aov model="depth_aov" />')
        if asr_scene_props.pixel_time_aov:
            self.__emit_line('<aov model="pixel_time_aov" />')

        self.__close_element("aovs")

    def __get_frame_resolution(self, render):
        scale = render.resolution_percentage / 100.0
        width = int(render.resolution_x * scale)
        height = int(render.resolution_y * scale)
        return width, height

    def __get_frame_aspect_ratio(self, render):
        width, height = self.__get_frame_resolution(render)
        xratio = width * render.pixel_aspect_x
        yratio = height * render.pixel_aspect_y
        return xratio / yratio

    def __get_border_limits(self, scene, width, height):
        min_x = int(scene.render.border_min_x * width)
        max_x = int(scene.render.border_max_x * width)
        min_y = height - int(scene.render.border_max_y * height) - 1
        max_y = height - int(scene.render.border_min_y * height) - 1
        return min_x, min_y, max_x, max_y

    def __emit_configurations(self, scene):
        self.__open_element("configurations")
        self.__emit_interactive_configuration_element(scene)
        self.__emit_final_configuration_element(scene)
        self.__close_element("configurations")

    def __emit_interactive_configuration_element(self, scene):
        self.__open_element('configuration name="interactive" base="base_interactive"')
        self.__emit_common_configuration_parameters(scene, "interactive")
        self.__close_element("configuration")

    def __emit_final_configuration_element(self, scene):
        self.__open_element('configuration name="final" base="base_final"')
        self.__emit_common_configuration_parameters(scene, "final")
        self.__open_element('parameters name="generic_tile_renderer"')
        self.__emit_parameter("min_samples", scene.appleseed.sampler_min_samples)
        self.__emit_parameter("max_samples", scene.appleseed.sampler_max_samples)
        self.__close_element("parameters")
        self.__close_element("configuration")

    def __emit_common_configuration_parameters(self, scene, type):

        self.__emit_parameter("pixel_renderer", scene.appleseed.pixel_sampler)
        self.__emit_parameter("lighting_engine", scene.appleseed.lighting_engine)
        self.__open_element('parameters name="adaptive_pixel_renderer"')
        self.__emit_parameter("min_samples", scene.appleseed.sampler_min_samples)
        self.__emit_parameter("max_samples", scene.appleseed.sampler_max_samples)
        self.__emit_parameter("quality", scene.appleseed.adaptive_sampler_quality)
        self.__emit_parameter("enable_diagnostics", scene.appleseed.adaptive_sampler_enable_diagnostics)
        self.__close_element("parameters")

        self.__open_element('parameters name="uniform_pixel_renderer"')
        self.__emit_parameter("decorrelate_pixels", "true" if scene.appleseed.decorrelate_pixels else "false")
        self.__emit_parameter("force_antialiasing", "true" if scene.appleseed.force_aa else "false")
        self.__emit_parameter("samples", scene.appleseed.sampler_max_samples)
        self.__close_element("parameters")

        self.__open_element('parameters name="generic_frame_renderer"')
        self.__emit_parameter("passes", scene.appleseed.renderer_passes)
        self.__emit_parameter("tile_ordering", scene.appleseed.tile_ordering)
        self.__close_element("parameters")

        self.__open_element('parameters name="light_sampler"')
        self.__emit_parameter("algorithm", scene.appleseed.light_sampler)
        self.__close_element("parameters")

        self.__emit_parameter("shading_result_framebuffer", "permanent" if scene.appleseed.renderer_passes > 1 else "ephemeral")

        self.__open_element('parameters name="{0}"'.format(scene.appleseed.lighting_engine))

        # IBL can be enabled with all three engines.
        self.__emit_parameter("enable_ibl", "true" if scene.appleseed.enable_ibl else "false")

        if scene.appleseed.lighting_engine == 'pt':
            self.__emit_parameter("enable_dl", "true" if scene.appleseed.enable_dl else "false")
            self.__emit_parameter("enable_caustics", "true" if scene.appleseed.enable_caustics else "false")
            self.__emit_parameter("record_light_paths", "true" if scene.appleseed.record_light_paths else "false")
            self.__emit_parameter("next_event_estimation", "true" if scene.appleseed.next_event_estimation else "false")
            if not scene.appleseed.max_ray_intensity_unlimited:
                self.__emit_parameter("max_ray_intensity", scene.appleseed.max_ray_intensity)
            self.__emit_parameter("dl_light_samples", scene.appleseed.dl_light_samples)
            if scene.appleseed.dl_low_light_threshold > 0.0:
                self.__emit_parameter("dl_low_light_threshold", scene.appleseed.dl_low_light_threshold)
            self.__emit_parameter("ibl_env_samples", scene.appleseed.ibl_env_samples)
            if not scene.appleseed.max_diffuse_bounces_unlimited:
                self.__emit_parameter("max_diffuse_bounces", scene.appleseed.max_diffuse_bounces)
            if not scene.appleseed.max_glossy_brdf_bounces_unlimited:
                self.__emit_parameter("max_glossy_brdf_bounces", scene.appleseed.max_glossy_brdf_bounces)
            if not scene.appleseed.max_specular_bounces_unlimited:
                self.__emit_parameter("max_specular_bounces", scene.appleseed.max_specular_bounces)
            if not scene.appleseed.max_volume_bounces_unlimited:
                self.__emit_parameter("max_volume_bounces", scene.appleseed.max_volume_bounces)
            if not scene.appleseed.max_bounces_unlimited:
                self.__emit_parameter("max_bounces", scene.appleseed.max_bounces)
            self.__emit_parameter("rr_min_path_length", scene.appleseed.rr_start)
            self.__emit_parameter("optimize_for_lights_outside_volumes", scene.appleseed.optimize_for_lights_outside_volumes)
            self.__emit_parameter("volume_distance_samples", scene.appleseed.volume_distance_samples)
        else:
            self.__emit_parameter("alpha", scene.appleseed.sppm_alpha)
            self.__emit_parameter("dl_mode", scene.appleseed.sppm_dl_mode)
            self.__emit_parameter("enable_caustics", "true" if scene.appleseed.enable_caustics else "false")
            self.__emit_parameter("env_photons_per_pass", scene.appleseed.sppm_env_photons)
            self.__emit_parameter("initial_radius", scene.appleseed.sppm_initial_radius)
            self.__emit_parameter("light_photons_per_pass", scene.appleseed.sppm_light_photons)

            # Leave at 0 for now - not in appleseed.studio GUI
            self.__emit_parameter("max_path_length", 0)
            self.__emit_parameter("max_photons_per_estimate", scene.appleseed.sppm_max_per_estimate)
            self.__emit_parameter("path_tracing_max_path_length", scene.appleseed.sppm_pt_max_length)
            self.__emit_parameter("path_tracing_rr_min_path_length", scene.appleseed.sppm_pt_rr_start)
            self.__emit_parameter("photon_tracing_max_path_length", scene.appleseed.sppm_photon_max_length)
            self.__emit_parameter("photon_tracing_rr_min_path_length", scene.appleseed.sppm_photon_rr_start)

            # Leave RR path length at 3 - also not in appleseed.studio GUI
            self.__emit_parameter("rr_min_path_length", 3)

        self.__close_element('parameters')

    def __emit_color_element(self, name, color_space, values, alpha, multiplier):
        self.__open_element('color name="{0}"'.format(name))
        self.__emit_parameter("color_space", color_space)
        self.__emit_parameter("multiplier", multiplier)
        self.__emit_line("<values>{0}</values>".format(" ".join(map(str, values))))
        if alpha:
            self.__emit_line("<alpha>{0}</alpha>".format(" ".join(map(str, alpha))))
        self.__close_element("color")

    """
    A note on color spaces:
    
    Internally, Blender stores colors as linear RGB values, and the numeric color values
    we get from color pickers are linear RGB values, although the color swatches and color
    pickers show gamma corrected colors. This explains why we pretty much exclusively use
    __emit_solid_linear_rgb_color_element() instead of __emit_solid_srgb_color_element().
    """

    def __emit_solid_linear_rgb_color_element(self, name, values, multiplier):
        self.__emit_color_element(name, "linear_rgb", values, None, multiplier)

    def __emit_solid_srgb_color_element(self, name, values, multiplier):
        self.__emit_color_element(name, "srgb", values, None, multiplier)

    def __emit_transform_element(self, m, time):
        """
        We have the following conventions:

        Both Blender and appleseed use right-hand coordinate systems.
        Both Blender and appleseed use column-major matrices.
        Both Blender and appleseed use pre-multiplication.
        In Blender, given a matrix m, m[i][j] is the element at the i'th row, j'th column.

        The only difference between the coordinate systems of Blender and appleseed is the up vector:
        in Blender, up is Z+; in appleseed, up is Y+. We can go from Blender's coordinate system to
        appleseed's one by rotating by +90 degrees around the X axis. That means that Blender
        objects must be rotated by -90 degrees around X before being exported to appleseed.
        """

        if time is not None:
            self.__open_element('transform time="%.2f"' % time)
        else:
            self.__open_element("transform")
        self.__open_element("matrix")
        self.__emit_line("{0} {1} {2} {3}".format(m[0][0], m[0][1], m[0][2], m[0][3]))
        self.__emit_line("{0} {1} {2} {3}".format(m[2][0], m[2][1], m[2][2], m[2][3]))
        self.__emit_line("{0} {1} {2} {3}".format(-m[1][0], -m[1][1], -m[1][2], -m[1][3]))
        self.__emit_line("{0} {1} {2} {3}".format(m[3][0], m[3][1], m[3][2], m[3][3]))
        self.__close_element("matrix")
        self.__close_element("transform")

    def __emit_custom_prop(self, object, prop_name, default_value):
        value = self.__get_custom_prop(object, prop_name, default_value)
        self.__emit_parameter(prop_name, value)

    def __get_custom_prop(self, object, prop_name, default_value):
        if prop_name in object:
            return object[prop_name]
        else:
            return default_value

    def __emit_parameter(self, name, value):
        self.__emit_line("<parameter name=\"" + name + "\" value=\"" + str(value) + "\" />")

    def __emit_shader_connection(self, src_layer, src_param, dest_layer, dest_param):
        self.__emit_line('<connect_shaders src_layer="{0}" src_param="{1}" dst_layer="{2}" dst_param="{3}" />'.format(src_layer, src_param, dest_layer, dest_param))

    def __open_element(self, name):
        self.__emit_line("<" + name + ">")
        self.__indent()

    def __close_element(self, name):
        self.__unindent()
        self.__emit_line("</" + name + ">")

    def __emit_line(self, line):
        self.__emit_indent()
        self._output_file.write(line + "\n")

    def __indent(self):
        self._indent += 1

    def __unindent(self):
        assert self._indent > 0
        self._indent -= 1

    def __emit_indent(self):
        IndentSize = 4
        self._output_file.write(" " * self._indent * IndentSize)

    def __error(self, message):
        self.__print_message("error", message)
        # self.report({ 'ERROR' }, message)

    def __warning(self, message):
        self.__print_message("warning", message)
        # self.report({ 'WARNING' }, message)

    def __info(self, message):
        if len(message) > 0:
            self.__print_message("info", message)
        else:
            print("")
            # self.report({ 'INFO' }, message)

    def __progress(self, message):
        self.__print_message("progress", message)

    def __print_message(self, severity, message):
        max_length = 8  # length of the longest severity string
        padding_count = max_length - len(severity)
        padding = " " * padding_count
        print("{0}{1} : {2}".format(severity, padding, message))

    def export_preview(self, scene, file_path, mat, mesh, width, height):
        """
        Write the .appleseed project file for preview rendering
        """

        self._textures_set = set()

        asr_mat = mat.appleseed
        sphere_a = True if mesh == 'sphere_a' else False
        mesh = 'sphere' if mesh in {'sphere', 'sphere_a'} else mesh

        try:
            with codecs.open(file_path, "w", "utf-8") as self._output_file:
                self._indent = 0
                self.__emit_file_header()
                aspect_ratio = self.__get_frame_aspect_ratio(scene.render)

                self._output_file.write("""<project>
""")
                self.__emit_search_paths()
                self._output_file.write(
                    """<scene>
        <camera name="Camera" model="pinhole_camera">
            <parameter name="film_width" value="0.032" />
            <parameter name="aspect_ratio" value="{0}" />
            <parameter name="focal_length" value="0.035" />
            <transform>
                <look_at origin="0.0 0.04963580518960953 0.23966674506664276" target="0.0 0.04963589459657669 0.13966673612594604" up="0.0 0.10000001639127731 8.781765359344718e-08" />
            </transform>
        </camera>""".format(aspect_ratio))

                # Environment EDF.
                if not sphere_a:
                    self._output_file.write("""
        <color name="horizon_radiance">
            <parameter name="color_space" value="linear_rgb" />
            <parameter name="multiplier" value="1.0" />
            <values>0.4 0.4 0.4</values>
        </color>
        <color name="zenith_radiance">
            <parameter name="color_space" value="linear_rgb" />
            <parameter name="multiplier" value="1.0" />
            <values>0.0 0.0 0.0</values>
        </color>
        <environment_edf name="environment_edf" model="constant_environment_edf">
            <parameter name="radiance" value="horizon_radiance" />
        </environment_edf>""")
                else:
                    self._output_file.write("""
        <color name="horizon_radiance">
            <parameter name="color_space" value="linear_rgb" />
            <parameter name="multiplier" value="1.0" />
            <values>0.8 0.77 0.7</values>
        </color>
        <color name="zenith_radiance">
            <parameter name="color_space" value="linear_rgb" />
            <parameter name="multiplier" value="1.0" />
            <values>0.5 0.5 0.9</values>
        </color>
        <environment_edf name="environment_edf" model="gradient_environment_edf">
            <parameter name="horizon_radiance" value="horizon_radiance" />
            <parameter name="zenith_radiance" value="zenith_radiance" />
        </environment_edf>""")

                # Environment shader and environment.
                self._output_file.write("""
        <environment_shader name="environment_shader" model="edf_environment_shader">
            <parameter name="environment_edf" value="environment_edf" />
        </environment_shader>
        <environment name="environment" model="generic_environment">
            <parameter name="environment_edf" value="environment_edf" />
            <parameter name="environment_shader" value="environment_shader" />
        </environment>""")

                # Preview lamp mesh.
                self._output_file.write("""
        <assembly name="mat_preview">
            <surface_shader name="physical_surface_shader" model="physical_surface_shader" />
            <color name="__default_material_albedo">
                <parameter name="color_space" value="linear_rgb" />
                <parameter name="multiplier" value="1.0" />
                <values>0.8 0.8 0.8</values>
            </color>
            <color name="__default_material_bsdf_reflectance">
                <parameter name="color_space" value="linear_rgb" />
                <parameter name="multiplier" value="1.0" />
                <values>0.8</values>
            </color>
            <bsdf name="__default_material_bsdf" model="lambertian_brdf">
                <parameter name="reflectance" value="__default_material_bsdf_reflectance" />
            </bsdf>
            <material name="__default_material" model="generic_material">
                <parameter name="bsdf" value="__default_material_bsdf" />
                <parameter name="surface_shader" value="physical_surface_shader" />
            </material>
            <object name="material_preview_lamp" model="mesh_object">
                <parameter name="filename" value="material_preview_lamp.obj" />
            </object>
            <color name="material_preview_lamp_material|BSDF Layer 1_lambertian_brdf_reflectance">
                <parameter name="color_space" value="linear_rgb" />
                <parameter name="multiplier" value="1.0" />
                <values>0.8 0.8 0.8</values>
            </color>
            <bsdf name="material_preview_lamp_material|BSDF Layer 1" model="lambertian_brdf">
                <parameter name="reflectance" value="material_preview_lamp_material|BSDF Layer 1_lambertian_brdf_reflectance" />
            </bsdf>
            <color name="material_preview_lamp_material_edf_radiance">
                <parameter name="color_space" value="linear_rgb" />
                <parameter name="multiplier" value="5.0" />
                <values>0.8 0.8 0.8</values>
            </color>
            <edf name="material_preview_lamp_material_edf" model="diffuse_edf">
                <parameter name="radiance" value="material_preview_lamp_material_edf_radiance" />
            </edf>
            <material name="material_preview_lamp_material" model="generic_material">
                <parameter name="bsdf" value="material_preview_lamp_material|BSDF Layer 1" />
                <parameter name="edf" value="material_preview_lamp_material_edf" />
                <parameter name="surface_shader" value="physical_surface_shader" />
            </material>
            <object_instance name="material_preview_lamp.part_0.instance_0" object="material_preview_lamp.part_0">
                <transform>
                    <matrix>
                        0.06069698929786682 0.07323580980300903 0.030860835686326027 0.0
                        0.0 -0.038832105696201324 0.0921524167060852 0.0
                        0.07947248220443726 -0.055933743715286255 -0.023569919168949127 -0.0
                        0.0 0.0 0.0 1.0
                    </matrix>
                </transform>
                <assign_material slot="0" side="front" material="material_preview_lamp_material" />
                <assign_material slot="0" side="back" material="__default_material" />
            </object_instance>
            <object name="material_preview_ground" model="mesh_object">
                <parameter name="filename" value="material_preview_ground.obj" />
            </object>""")

                # Preview ground plane.
                if not sphere_a:
                    self._output_file.write("""
            <texture name="material_preview_checker_texture" model="disk_texture_2d">
                <parameter name="color_space" value="srgb" />
                <parameter name="filename" value="checker_texture.png" />
            </texture>
            <texture_instance name="material_preview_checker_texture_inst" texture="material_preview_checker_texture">
                <parameter name="addressing_mode" value="wrap" />
                <parameter name="filtering_mode" value="bilinear" />
            </texture_instance>
            <bsdf name="material_preview_plane_material|BSDF Layer 1" model="lambertian_brdf">
                <parameter name="reflectance" value="material_preview_checker_texture_inst" />
            </bsdf>
            <material name="material_preview_plane_material" model="generic_material">
                <parameter name="bsdf" value="material_preview_plane_material|BSDF Layer 1" />
                <parameter name="surface_shader" value="physical_surface_shader" />
            </material>
            <object_instance name="material_preview_ground.part_0.instance_0" object="material_preview_ground.part_0">
                <transform>
                    <matrix>
                        0.10000000149011612 0.0 0.0 0.0
                        0.0 0.0 0.10000000149011612 0.0
                        -0.0 -0.10000000149011612 -0.0 -0.0
                        0.0 0.0 0.0 1.0
                    </matrix>
                </transform>
                <assign_material slot="0" side="front" material="material_preview_plane_material" />
                <assign_material slot="0" side="back" material="material_preview_plane_material" />
            </object_instance>""")

                # Preview mesh.
                mat_front = mat.name
                mat_back = mat.name
                asr_node_tree = asr_mat.osl_node_tree
                if self.__is_node_material(asr_mat, asr_node_tree):
                    for node in asr_node_tree.nodes:
                        if node.node_type == 'osl_surface':
                            material_node = node
                    node_list = material_node.traverse_tree()
                else:
                    if asr_mat.bsdf_type in ['specular_btdf', 'diffuse_btdf']:
                        mat_front = mat.name + "_front"
                        mat_back = mat.name + "_back"
                self._output_file.write("""
            <object name="material_preview_{0}" model="mesh_object">
                <parameter name="filename" value="material_preview_{0}.obj" />
            </object>
            <object_instance name="material_preview_{0}.part_0.instance_0" object="material_preview_{0}.part_0">
                <transform>
                    <matrix>
                        0.10000000149011612 0.0 0.0 0.0
                        0.0 0.0 0.10000000149011612 0.0
                        -0.0 -0.10000000149011612 -0.0 -0.0
                        0.0 0.0 0.0 1.0
                    </matrix>
                </transform>
                <assign_material slot="0" side="front" material="{1}" />
                <assign_material slot="0" side="back" material="{2}" />
            </object_instance>
""".format(mesh, mat_front, mat_back))

                # Material to preview.
                self.__emit_material(mat, scene)

                self._output_file.write("""        </assembly>
        <assembly_instance name="mat_preview_instance" assembly="mat_preview">
        </assembly_instance>
    </scene>
    <output>
        <frame name="beauty">
            <parameter name="camera" value="Camera" />
            <parameter name="resolution" value="{0} {1}" />
        </frame>
    </output>
    <configurations>
        <configuration name="interactive" base="base_interactive">
            <parameter name="lighting_engine" value="pt" />
            <parameters name="pt">
                <parameter name="dl_light_samples" value="1" />
                <parameter name="enable_ibl" value="true" />
                <parameter name="ibl_env_samples" value="1" />
                <parameter name="rr_min_path_length" value="3" />
            </parameters>
        </configuration>
        <configuration name="final" base="base_final">
            <parameter name="lighting_engine" value="pt" />
            <parameter name="pixel_renderer" value="uniform" />
            <parameters name="uniform_pixel_renderer">
                <parameter name="decorrelate_pixels" value="False" />
                <parameter name="samples" value="{2}" />
            </parameters>
            <parameters name="pt">
                <parameter name="dl_light_samples" value="1" />
                <parameter name="enable_ibl" value="true" />
                <parameter name="ibl_env_samples" value="1" />
                <parameter name="rr_min_path_length" value="3" />
            </parameters>
            <parameters name="generic_tile_renderer">
                <parameter name="min_samples" value="{2}" />
                <parameter name="max_samples" value="{2}" />
            </parameters>
        </configuration>
    </configurations>
</project>""".format(int(width), int(height), asr_mat.preview_quality))
                return True

        except IOError:
            self.__error("Failed to write to {0}.".format(file_path))
            return False
